@page "/composer"
@inject IJSRuntime JSRuntime
@using GUI.Shared.Services
@inject IQMDDSimulatorClient SimulatorClient
@inject NavigationManager NavigationManager
@using GUI.Shared.Models
@using System.Text.Json
@using Microsoft.AspNetCore.Components

<style>
.button {
    color: white;
    background-color: #512BD4;
    font-family: OpenSansRegular, sans-serif;
    font-size: 14px;
    padding: 10px 14px;
    min-height: 44px;
    min-width: 44px;
    border-width: 0px;
    border-radius: 8px;
}

.button:disabled {
    color: #141414;
    background-color: #C8C8C8;
}

.h-gate {
    position: relative;
    text-align: center;
    width: 40px;
    height: 40px;
    line-height: 40px;
    border: none;
    border-radius: 0px;
    background-color: #fa4d56;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.h-gate p {
    margin: 0;
    padding: 0;
}

.classical-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #4588ff;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.classical-gate p {
    margin: 0;
    padding: 0;
}

.phase-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #bae6fe;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.phase-gate p {
    margin: 0;
    padding: 0;
}

.other-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #a1a9af;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.other-gate p {
    margin: 0;
    padding: 0;
}

.trash-zone {
    position: static;
    transform: none;
    z-index: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: linear-gradient(145deg, #ff6b6b, #ee5a52);
    box-shadow: 
        0 8px 20px rgba(238, 90, 82, 0.3),
        inset 0 -3px 10px rgba(0, 0, 0, 0.1),
        inset 0 3px 10px rgba(255, 255, 255, 0.2);
    cursor: default;
    user-select: none;
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    overflow: hidden;
}

.trash-zone:hover {
    transform: scale(1.05);
    box-shadow: 
        0 12px 25px rgba(238, 90, 82, 0.4),
        inset 0 -3px 10px rgba(0, 0, 0, 0.1),
        inset 0 3px 10px rgba(255, 255, 255, 0.3);
}

.trash-zone.drag-over {
    transform: translateY(-50%) scale(1.1);
    background: linear-gradient(145deg, #27ae60, #229954);
    box-shadow: 
        0 20px 40px rgba(39, 174, 96, 0.5),
        inset 0 -3px 10px rgba(0, 0, 0, 0.2),
        inset 0 3px 10px rgba(255, 255, 255, 0.4);
    animation: pulse 0.6s infinite alternate;
}

@@keyframes pulse {
    0% { box-shadow: 0 20px 40px rgba(39, 174, 96, 0.5), inset 0 -3px 10px rgba(0, 0, 0, 0.2), inset 0 3px 10px rgba(255, 255, 255, 0.4); }
    100% { box-shadow: 0 25px 50px rgba(39, 174, 96, 0.7), inset 0 -5px 15px rgba(0, 0, 0, 0.3), inset 0 5px 15px rgba(255, 255, 255, 0.5); }
}

.trash-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 2;
}

.trash-icon {
    color: white;
    margin-bottom: 8px;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    transition: transform 0.2s ease;
}

.trash-zone:hover .trash-icon {
    transform: scale(1.1) rotateZ(5deg);
}

.trash-zone.drag-over .trash-icon {
    transform: scale(1.2) rotateZ(-5deg);
    animation: shake 0.3s ease-in-out infinite;
}

@@keyframes shake {
    0%, 100% { transform: scale(1.2) rotateZ(-5deg) translateX(0); }
    25% { transform: scale(1.2) rotateZ(-5deg) translateX(-2px); }
    75% { transform: scale(1.2) rotateZ(-5deg) translateX(2px); }
}

.trash-text {
    margin: 0;
    padding: 0;
    font-size: 9px;
    font-weight: 600;
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    text-align: center;
    line-height: 1.2;
    transition: all 0.2s ease;
}

.trash-zone:hover .trash-text {
    transform: scale(1.05);
}

.trash-glow {
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255, 107, 107, 0.3) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
}

.trash-zone:hover .trash-glow {
    opacity: 1;
}

.trash-zone.drag-over .trash-glow {
    background: radial-gradient(circle, rgba(39, 174, 96, 0.4) 0%, transparent 70%);
    opacity: 1;
}

.x-gate {
    width: 40px;
    height: 40px;
}

.x-gate:hover {
    filter: brightness(0.9);
}

.qubit-line {
    position: relative;
    flex-grow: 1;
    height: 1px;
    min-height: 30px;
    background-color: transparent;
    border: none;
    margin: 0;
    padding: 15px 0;
    background-image: 
        linear-gradient(to right, rgba(128, 128, 128, 0.2) 1px, transparent 1px);
    background-size: 50px 1px;
    background-position: 0 50%;
    transition: all 0.2s ease;
    cursor: crosshair;
    pointer-events: auto;
}

.qubit-line::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    background-color: currentColor;
    transform: translateY(-50%);
    z-index: 1;
}

.stepper {
    display: flex;
    align-items: center;
    gap: 8px;
}

.stepper-button {
    min-width: 44px;
    min-height: 44px;
    padding: 0;
    font-size: 20px;
    font-weight: bold;
}

.stepper-input {
    width: 80px;
    height: 44px;
    text-align: center;
    font-size: 16px;
    border: 1px solid #512BD4;
    border-radius: 8px;
    padding: 0 8px;
}

.stepper-input:focus {
    outline: none;
    box-shadow: 0 0 0 0.1rem white, 0 0 0 0.25rem #258cfb;
}

.gate-section {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 3px;
    margin-bottom: 5px;
}

.gate-section label {
    color: #333;
    font-weight: 600;
    margin-bottom: 2px;
    font-size: 13px;
}

.gate-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
}

.horizontal-container {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-right: 160px;
}

.vertical-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
}

.dragging {
    opacity: 0.5;
    transform: scale(0.9);
    transition: all 0.2s ease;
}

.dropped-gate {
    min-width: 30px !important;
    min-height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-size: 14px !important;
    border-radius: 0px !important;
    user-select: none !important;
    text-align: center !important;
    line-height: normal !important;
    font-family: OpenSansRegular, sans-serif !important;
    font-weight: medium !important;
    border: none !important;
    cursor: grab !important;
    position: absolute !important;
    transform: translateY(-50%) !important;
    z-index: 10 !important;
    pointer-events: auto !important;
    transition: all 0.2s ease !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

.dropped-gate.h-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #fa4d56 !important;
    color: black !important;
    font-size: 20px !important;
    line-height: 40px !important;
}

.dropped-gate.classical-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #4588ff !important;
    color: black !important;
    font-size: 18px !important;
    line-height: 40px !important;
}

.dropped-gate.phase-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #bae6fe !important;
    color: black !important;
    font-size: 18px !important;
    line-height: 40px !important;
}

.dropped-gate.other-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #a1a9af !important;
    color: black !important;
    font-size: 16px !important;
    line-height: 40px !important;
}

.dropped-gate:hover {
    opacity: 0.8 !important;
    cursor: grab !important;
    filter: brightness(1.1) !important;
    transform: translateY(-50%) scale(1.05) !important;
}

.dropped-gate.dragging {
    opacity: 0.5 !important;
    cursor: grabbing !important;
    transform: translateY(-50%) scale(0.9) !important;
    transition: all 0.2s ease !important;
    z-index: 1000 !important;
}

.qubit-line:hover {
    height: 3px !important;
    background-color: #512BD4 !important;
    transition: all 0.2s ease;
}

.gate-palette {
    background-color: #f5f5f5;
    padding: 8px;
    border-radius: 6px;
    border: 2px dashed #ccc;
    min-width: 400px;
}

.gate-palette h3 {
    margin-top: 0;
    margin-bottom: 5px;
    color: #333;
    font-size: 18px;
}

.usage-hint {
    font-size: 12px;
    color: #666;
    margin: -3px 0 5px 0;
    padding: 8px;
    background-color: rgba(81, 43, 212, 0.1);
    border-radius: 4px;
    border-left: 3px solid #512BD4;
}

@@media (prefers-color-scheme: dark) {
    .button {
        color: #242424;
        background-color: #ac99ea;
    }

    .button:disabled {
        color: #c8c8c8;
        background-color: #404040;
    }

    .stepper-input {
        background-color: #242424;
        color: #fff;
        border-color: #ac99ea;
    }

    .gate-palette {
        background-color: #2d2d2d;
        border-color: #555;
    }

    .gate-palette h3 {
        color: #fff;
    }

    .usage-hint {
        color: #ccc;
        background-color: rgba(172, 153, 234, 0.1);
        border-left-color: #ac99ea;
    }

    .gate-palette label {
        color: #ccc;
    }

    .gate-section label {
        color: #ccc;
        font-size: 13px;
    }

    .qubit-line:hover {
        background-color: #ac99ea !important;
    }
}

.dropped-gate p {
    margin: 0 !important;
    padding: 0 !important;
    color: inherit !important;
    font-size: inherit !important;
    line-height: inherit !important;
}

.dropped-gate svg {
    width: 25px !important;
    height: 25px !important;
    display: inline-block !important;
    vertical-align: middle !important;
}

.dropped-gate sup {
    font-size: 0.7em !important;
    vertical-align: super !important;
    line-height: 0 !important;
}

.dropped-gate sub {
    font-size: 0.7em !important;
    vertical-align: sub !important;
    line-height: 0 !important;
}

.header-container {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 20px;
    gap: 30px;
}

.title-section {
    flex: 1;
}

.controls-section {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 15px;
    margin-top: 10px;
}
</style>

<div class="header-container">
    <div class="title-section">
        <h1>Composer</h1>
        <div class="controls-section">
            <div class="stepper-section">
                <p role="status">number of qubits: @currentCount</p>
                <div class="stepper">
                    <button class="button stepper-button" @onclick="DecrementCount">-</button>
                    <input type="number" 
                        class="stepper-input" 
                        value="@currentCount"
                        @onchange="OnInputChange" />
                    <button class="button stepper-button" @onclick="IncrementCount">+</button>
                </div>
            </div>
            
            <div style="display: flex; align-items: center; gap: 20px;">
                <!-- ゴミ箱エリア -->
                <div class="trash-zone" title="ここにゲートをドラッグして削除">
                    <div class="trash-container">
                        <svg class="trash-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path d="M19 7H16V6C16 4.89 15.11 4 14 4H10C8.89 4 8 4.89 8 6V7H5C4.45 7 4 7.45 4 8S4.45 9 5 9H6V19C6 20.11 6.89 21 8 21H16C17.11 21 18 20.11 18 19V9H19C19.55 9 20 8.55 20 8S19.55 7 19 7ZM10 6H14V7H10V6ZM16 19H8V9H16V19Z" fill="currentColor"/>
                            <path d="M10 11V17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            <path d="M14 11V17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        <p class="trash-text">ゲートを削除</p>
                        <div class="trash-glow"></div>
                    </div>
                </div>
                
                <!-- Runボタン -->
                <button class="button" @onclick="SimulateCircuit" disabled="@isSimulating">
                    @if (isSimulating)
                    {
                        <span>🔄 Running...</span>
                    }
                    else
                    {
                        <span>▶️ Run</span>
                    }
                </button>
            </div>
        </div>
    </div>

    <div class="vertical-container gate-palette">
        <h3>量子ゲートパレット</h3>
        <p class="usage-hint">💡 ゲートをドラッグして量子ビット線上に配置できます。ダブルクリックで削除、ゴミ箱にドラッグしても削除できます。</p>        <div class="gate-section">
            <label>基本ゲート:</label>
            <div class="gate-row">
                <div class="h-gate" draggable="true" title="Hadamardゲート">H</div>
            </div>
        </div>

        <div class="gate-section">
            <label>クラシカルゲート:</label>
            <div class="gate-row">
                <div class="classical-gate" draggable="true" title="Xゲート（Pauliゲート）">
                    <svg class="x-gate" viewBox="0 0 25 25" width="25" height="25">
                        <circle cx="12.5" cy="12.5" r="6.25" stroke="black" stroke-width="1" fill="none"/>
                        <line x1="6.25" y1="12.5" x2="18.75" y2="12.5" stroke="black" stroke-width="1"/>
                        <line x1="12.5" y1="6.25" x2="12.5" y2="18.75" stroke="black" stroke-width="1"/>
                    </svg>
                </div>
                <div class="classical-gate" draggable="true" title="Identityゲート">
                    <p>I</p>
                </div>
            </div>
        </div>

        <div class="gate-section">
            <label>位相ゲート:</label>
            <div class="gate-row">
                <div class="phase-gate" draggable="true" title="Tゲート">
                    <p>T</p>
                </div>
                <div class="phase-gate" draggable="true" title="T†ゲート">
                    <p>T<sup>†</sup></p>
                </div>
                <div class="phase-gate" draggable="true" title="Sゲート">
                    <p>S</p>
                </div>
                <div class="phase-gate" draggable="true" title="S†ゲート">
                    <p>S<sup>†</sup></p>
                </div>
                <div class="phase-gate" draggable="true" title="Vゲート">
                    <p>V</p>
                </div>
                <div class="phase-gate" draggable="true" title="V†ゲート">
                    <p>V<sup>†</sup></p>
                </div>
                <div class="phase-gate" draggable="true" title="Yゲート">
                    <p>Y</p>
                </div>
                <div class="phase-gate" draggable="true" title="Zゲート">
                    <p>Z</p>
                </div>
                <div class="phase-gate" draggable="true" title="位相ゲート">
                    <p>P</p>
                </div>
                <div class="phase-gate" draggable="true" title="回転Xゲート">
                    <p>Rx</p>
                </div>
                <div class="phase-gate" draggable="true" title="回転Yゲート">
                    <p>Ry</p>
                </div>
                <div class="phase-gate" draggable="true" title="回転Zゲート">
                    <p>Rz</p>
                </div>
            </div>
        </div>

        <div class="gate-section">
            <label>その他:</label>
            <div class="gate-row">
                <div class="other-gate" draggable="true" title="初期状態">
                    <p>|0⟩</p>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private int currentCount = 2;
    private bool isSimulating = false;
    private GUI.Shared.Models.SimulationResult? lastResult = null; // **明示的に名前空間を指定**
    private string statusMessage = "";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {
            if (firstRender)
            {
                // 少し待ってからJavaScriptを呼び出す
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.initializeDragAndDrop");
            }
            else
            {
                // 量子ビット数が変更された時にドロップゾーンを再初期化
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
        }
        catch (Exception ex)
        {
            // JavaScript関数がまだ読み込まれていない場合は無視
            Console.WriteLine($"JavaScript function not yet available: {ex.Message}");
        }
    }

    private async Task SimulateCircuit()
    {
        isSimulating = true;
        statusMessage = "🔄 回路データを取得中...";
        StateHasChanged();

        try
        {
            // シミュレータが利用可能かチェック
            if (!await SimulatorClient.IsSimulatorAvailableAsync())
            {
                statusMessage = "❌ QMDD Simulator is not available. Please start the simulator with -s flag.";
                return;
            }

            // JavaScriptから現在の回路データを取得
            var circuitDataJson = await JSRuntime.InvokeAsync<string>("getCircuitData");
            
            if (string.IsNullOrEmpty(circuitDataJson))
            {
                statusMessage = "⚠️ No circuit data found. Please add some gates first.";
                return;
            }

            var circuitData = JsonSerializer.Deserialize<CircuitData>(circuitDataJson, 
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (circuitData == null)
            {
                statusMessage = "⚠️ Failed to parse circuit data. Please try again.";
                return;
            }

            var request = BuildCircuitRequest(circuitData);
            
            if (request.Gates.Count == 0)
            {
                statusMessage = "⚠️ No gates in circuit. Please add some gates first.";
                return;
            }

            // シミュレーション実行
            statusMessage = $"🚀 Simulating circuit with {request.Gates.Count} gates on {request.NumQubits} qubits...";
            StateHasChanged();

            lastResult = await SimulatorClient.SimulateCircuitAsync(request);
            
            if (lastResult.Success)
            {
                statusMessage = $"✅ Simulation completed successfully in {lastResult.ExecutionTime:F2}ms";
                
                // **SaveResultForHeartbeatと同じ形式でデータを構成**
                var simulationData = new
                {
                    Success = lastResult.Success,
                    GateCount = request.Gates.Count,
                    ExecutionTime = lastResult.ExecutionTime,
                    Gates = request.Gates.Select((gate, index) => new
                    {
                        GateNumber = index + 1,
                        Type = gate.Type,
                        Label = $"Gate {index + 1} ({gate.Type})",
                        Qubits = gate.Qubits,
                        ControlQubits = gate.ControlQubits
                    }).ToList(),
                    Timestamp = DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"),
                    FinalState = lastResult.FinalState,
                    DetailedLog = lastResult.GateExecutionLogs.Select(log => new
                    {
                        GateNumber = log.GateNumber,
                        GateLabel = log.GateLabel,
                        GateType = log.GateType,
                        Qubits = log.Qubits,
                        ControlQubits = log.ControlQubits,
                        CurrentGate = new
                        {
                            Weight = log.CurrentGate.Weight,
                            Key = log.CurrentGate.Key,
                            IsTerminal = log.CurrentGate.IsTerminal
                        },
                        CurrentState = new
                        {
                            Weight = log.CurrentState.Weight,
                            Key = log.CurrentState.Key,
                            IsTerminal = log.CurrentState.IsTerminal
                        }
                    }).ToList()
                };

                Console.WriteLine($"🎯 Composer saving result - DetailedLog count: {simulationData.DetailedLog.Count()}");

                await JSRuntime.InvokeVoidAsync("sessionStorage.setItem", "simulationResult", 
                    JsonSerializer.Serialize(simulationData, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));
                
                Console.WriteLine("💾 Composer result saved to session storage");
                
                // Heartbeatページに移動
                NavigationManager.NavigateTo("/heartbeat");
            }
            else
            {
                statusMessage = $"❌ Simulation failed: {lastResult.ErrorMessage}";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"💥 Error: {ex.Message}";
        }
        finally
        {
            isSimulating = false;
            StateHasChanged();
        }
    }

    private CircuitRequest BuildCircuitRequest(CircuitData? circuitData)
    {
        var request = new CircuitRequest
        {
            NumQubits = currentCount, // **現在設定されている量子ビット数を正しく使用**
            Gates = new List<GateCommand>()
        };

        if (circuitData?.Qubits == null) return request;

        // **グローバル順序が存在する場合は必ずそれを使用（時系列順序）**
        if (circuitData.GlobalGateOrder != null && circuitData.GlobalGateOrder.Count > 0)
        {
            Console.WriteLine($"🔄 Using global gate order: {circuitData.GlobalGateOrder.Count} gates");
            
            // **物理順ソート後のゲート順序をデバッグ出力**
            var sortedGates = circuitData.GlobalGateOrder
                .OrderBy(g => g.ColumnIndex)
                .ThenBy(g => g.RowIndex)
                .ThenBy(g => g.GateIndex)
                .ToList();
            
            Console.WriteLine("📊 Gate execution order (Column→Row→Index):");
            foreach (var gate in sortedGates)
            {
                Console.WriteLine($"  Gate: {gate.Type} | Column: {gate.ColumnIndex} | Row: {gate.RowIndex} | Qubit: {gate.QubitIndex}");
            }
            
            // グローバル順序に従ってゲートを処理（回路の物理順：左から右→上から下）
            foreach (var globalGate in sortedGates)
            {
                Console.WriteLine($"🎯 Processing gate {globalGate.GateIndex}: {globalGate.Type} on qubit {globalGate.QubitIndex}");
                
                if (globalGate.QubitIndex >= 0 && globalGate.QubitIndex < currentCount)
                {
                    var gateCommand = new GateCommand
                    {
                        Type = ConvertGateType(globalGate.Type),
                        Qubits = new List<int> { globalGate.QubitIndex }
                    };
                    
                    Console.WriteLine($"✅ Added gate: {gateCommand.Type} on qubit {globalGate.QubitIndex}");
                    request.Gates.Add(gateCommand);
                }
                else
                {
                    Console.WriteLine($"⚠️ Skipping gate on invalid qubit {globalGate.QubitIndex}");
                }
            }
        }
        else
        {
            // **従来通りの処理（後方互換性のため）**
            for (int qubitIndex = 0; qubitIndex < Math.Min(circuitData.Qubits.Count, currentCount); qubitIndex++)
            {
                var qubitGates = circuitData.Qubits[qubitIndex].Gates;
                
                if (qubitGates == null) continue;
                
                foreach (var gate in qubitGates)
                {
                    if (gate?.Type == null) continue;
                    
                    var gateCommand = new GateCommand
                    {
                        Type = ConvertGateType(gate.Type),
                        Qubits = new List<int> { qubitIndex }
                    };
                    
                    // 2量子ビットゲートの場合
                    if (gate.Type == "CNOT" || gate.Type == "CZ")
                    {
                        if (gate.TargetQubit.HasValue && gate.TargetQubit.Value < currentCount)
                        {
                            gateCommand.ControlQubits = new List<int> { qubitIndex };
                            gateCommand.Qubits = new List<int> { gate.TargetQubit.Value };
                        }
                    }
                    
                    // 回転ゲートの角度設定
                    if (gate.Angle.HasValue)
                    {
                        gateCommand.Angle = gate.Angle.Value;
                    }
                    
                    request.Gates.Add(gateCommand);
                }
            }
        }

        return request;
    }

    private string ConvertGateType(string guiGateType)
    {
        // GUIでのゲート表示名をシミュレータで使用される名前に変換
        return guiGateType switch
        {
            "H" => "H",
            "X" => "X",
            "I" => "I",
            "T" => "T",
            "T†" => "Tdg",
            "S" => "S", 
            "S†" => "Sdg",
            "V" => "V",
            "V†" => "Vdg",
            "Y" => "Y",
            "Z" => "Z",
            "P" => "P",
            "Rx" => "RX",
            "Ry" => "RY",
            "Rz" => "RZ",
            "|0⟩" => "Reset",
            _ => guiGateType
        };
    }

    private string GenerateGateLabel(string gateType, List<int> qubits, List<int>? controlQubits = null)
    {
        var label = gateType switch
        {
            "H" => "Hadamard Gate",
            "X" => "Pauli-X Gate", 
            "Y" => "Pauli-Y Gate",
            "Z" => "Pauli-Z Gate",
            "I" => "Identity Gate",
            "T" => "T Gate",
            "Tdg" => "T† Gate (T-dagger)",
            "S" => "S Gate",
            "Sdg" => "S† Gate (S-dagger)",
            "V" => "V Gate",
            "Vdg" => "V† Gate (V-dagger)",
            "P" => "Phase Gate",
            "RX" => "Rotation-X Gate",
            "RY" => "Rotation-Y Gate",
            "RZ" => "Rotation-Z Gate",
            "CNOT" => "Controlled-X Gate",
            "CZ" => "Controlled-Z Gate",
            "Reset" => "Reset to |0⟩",
            _ => $"{gateType} Gate"
        };

        // 量子ビット情報を追加
        if (controlQubits?.Count > 0)
        {
            return $"{label} [Control: {string.Join(",", controlQubits)} → Target: {string.Join(",", qubits)}]";
        }
        else
        {
            return $"{label} [Qubit: {string.Join(",", qubits)}]";
        }
    }

    private int GetNumQubits()
    {
        return currentCount;
    }

    private async Task IncrementCount()
    {
        currentCount++;
        StateHasChanged();
        try
        {
            await Task.Delay(50); // **DOM更新を確実に待つ**
            await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"JavaScript function not available: {ex.Message}");
        }
    }

    private async Task DecrementCount()
    {
        if (currentCount > 1) // **最小値を1に設定**
        {
            currentCount--;
            StateHasChanged();
            try
            {
                await Task.Delay(50); // **DOM更新を確実に待つ**
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript function not available: {ex.Message}");
            }
        }
    }

    private async Task OnInputChange(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int value) && value >= 1) // **最小値を1に設定**
        {
            currentCount = value;
            StateHasChanged();
            try
            {
                await Task.Delay(50); // **DOM更新を確実に待つ**
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript function not available: {ex.Message}");
            }
        }
    }
}

<!-- 量子回路エリア -->
<div class="circuit-area">
@for (int i = 0; i < currentCount; i++)
{
    <div style="display: flex; align-items: center; margin: 15px 0;">
        <span style="margin-right: 20px; font-size: 20px;">q<sub>@i</sub></span>
        <div class="qubit-line"></div>
    </div>
}
</div>

<!-- ステータス表示エリア -->
@if (!string.IsNullOrEmpty(statusMessage))
{
    <div style="margin: 20px 0; padding: 10px; background-color: @(lastResult?.Success == true ? "#d4edda" : "#f8d7da"); border-radius: 4px; border: 1px solid @(lastResult?.Success == true ? "#c3e6cb" : "#f5c6cb");">
        @statusMessage
    </div>
}

<script>
// ドラッグ&ドロップ機能の初期化
window.dragAndDropInterop = (function() {
    
    // プライベート変数
    let draggedElement = null;
    let isFromDroppedGate = false;
    let isDragging = false; // **重複防止フラグを追加**

    // ゲートのHTMLコンテンツを取得
    function getGateContent(element) {
        // SVGが含まれているかチェック
        if (element.querySelector('svg')) {
            // SVGを含む場合は全体のHTMLを保持
            return {
                type: 'html',
                content: element.innerHTML
            };
        } else if (element.querySelector('p')) {
            // pタグが含まれている場合はそのHTMLを保持
            return {
                type: 'html',
                content: element.innerHTML
            };
        } else {
            // プレーンテキストの場合
            return {
                type: 'text',
                content: element.textContent || 'H'
            };
        }
    }

    // ゲートタイプを取得
    function getGateType(element) {
        const classes = element.className.split(' ');
        return classes.find(cls => cls.endsWith('-gate')) || 'h-gate';
    }

    // ドラッグ開始
    function handleDragStart(e) {
        if (isDragging) { // **既にドラッグ中の場合は無視**
            e.preventDefault();
            return;
        }
        
        isDragging = true; // **ドラッグ開始をマーク**
        draggedElement = e.target;
        isFromDroppedGate = e.target.classList.contains('dropped-gate');
        
        e.target.classList.add('dragging');
        
        // ゲートの情報を保存
        const gateContent = getGateContent(e.target);
        const gateType = getGateType(e.target);
        
        const dragData = {
            gateType: gateType,
            isFromDropped: isFromDroppedGate,
            sourceId: isFromDroppedGate ? e.target.id || Date.now().toString() : null,
            contentType: gateContent.type,
            content: gateContent.content
        };
        
        e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
        e.dataTransfer.effectAllowed = isFromDroppedGate ? 'move' : 'copy';
    }

    // ドラッグ終了
    function handleDragEnd(e) {
        e.target.classList.remove('dragging');
        draggedElement = null;
        isFromDroppedGate = false;
        
        // **少し遅延してからフラグをリセット（重複防止）**
        setTimeout(() => {
            isDragging = false;
        }, 100);
    }

    // ドロップゾーンの初期化
    function initializeDropZones() {
        // 量子ビット線のドロップゾーン
        const qubitLines = document.querySelectorAll('.qubit-line');
        
        qubitLines.forEach((line, index) => {
            // 既存のイベントリスナーを削除
            line.removeEventListener('dragover', handleQubitDragOver);
            line.removeEventListener('drop', handleQubitDrop);
            line.removeEventListener('dragenter', handleQubitDragEnter);
            line.removeEventListener('dragleave', handleQubitDragLeave);
            
            // 新しいイベントリスナーを追加
            line.addEventListener('dragover', handleQubitDragOver);
            line.addEventListener('drop', handleQubitDrop);
            line.addEventListener('dragenter', handleQubitDragEnter);
            line.addEventListener('dragleave', handleQubitDragLeave);
            
            // ドロップゾーンが正しく設定されているかテスト
            line.style.minHeight = '20px';
            line.style.position = 'relative';
        });

        // ゴミ箱のドロップゾーン
        const trashZone = document.querySelector('.trash-zone');
        if (trashZone) {
            trashZone.removeEventListener('dragover', handleTrashDragOver);
            trashZone.removeEventListener('drop', handleTrashDrop);
            trashZone.removeEventListener('dragenter', handleTrashDragEnter);
            trashZone.removeEventListener('dragleave', handleTrashDragLeave);
            
            trashZone.addEventListener('dragover', handleTrashDragOver);
            trashZone.addEventListener('drop', handleTrashDrop);
            trashZone.addEventListener('dragenter', handleTrashDragEnter);
            trashZone.addEventListener('dragleave', handleTrashDragLeave);
        }
    }

    // 量子ビット線のドラッグイベント
    function handleQubitDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = isFromDroppedGate ? 'move' : 'copy';
    }

    function handleQubitDragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        const target = e.target.closest('.qubit-line') || e.target;
        target.style.backgroundColor = '#512BD4';
        target.style.height = '3px';
    }

    function handleQubitDragLeave(e) {
        e.stopPropagation();
        const target = e.target.closest('.qubit-line') || e.target;
        // 子要素からのleaveイベントを無視
        if (!target.contains(e.relatedTarget)) {
            target.style.backgroundColor = '';
            target.style.height = '1px';
        }
    }

    function handleQubitDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // **既に処理中の場合は無視**
        if (!isDragging) {
            return;
        }
        
        const target = e.target.closest('.qubit-line') || e.target;
        target.style.backgroundColor = '';
        target.style.height = '1px';
        
        try {
            const dragDataString = e.dataTransfer.getData('text/plain');
            
            if (!dragDataString) {
                return;
            }
            
            const data = JSON.parse(dragDataString);
            
            const qubitLine = target;
            
            // 移動の場合は元の要素を削除
            if (data.isFromDropped && draggedElement) {
                draggedElement.remove();
            }
            
            // **重複チェック: 同じデータで既存のゲートがある場合は作成しない**
            const existingGatesCount = qubitLine.querySelectorAll('.dropped-gate').length;
            
            // 新しいゲート要素を作成
            const newGate = document.createElement('div');
            newGate.className = data.gateType + ' dropped-gate';
            newGate.draggable = true;
            newGate.id = 'gate-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            
            // **タイムスタンプを追加（配置順序の追跡用）**
            newGate.dataset.timestamp = Date.now().toString();
            
            // コンテンツを設定
            if (data.contentType === 'html') {
                newGate.innerHTML = data.content;
            } else {
                newGate.textContent = data.content;
            }
            
            // ドロップ位置を計算（グリッドの縦線にスナップ）
            const rect = qubitLine.getBoundingClientRect();
            const dropX = e.clientX - rect.left;
            const gridSize = 50;
            const gateWidth = 40;
            const gateHalfWidth = gateWidth / 2;
            
            // 最も近い縦線の位置にスナップ
            const snappedX = Math.round(dropX / gridSize) * gridSize;
            const adjustedX = snappedX - gateHalfWidth;
            const maxX = qubitLine.offsetWidth - gateWidth;
            let finalX = Math.max(0 - gateHalfWidth, Math.min(adjustedX, maxX));
            
            // **重複チェックを改善**
            const existingGates = qubitLine.querySelectorAll('.dropped-gate');
            let positionOccupied = true;
            let attempts = 0;
            
            while (positionOccupied && attempts < 20) {
                positionOccupied = false;
                for (const existingGate of existingGates) {
                    const existingX = parseInt(existingGate.style.left) || 0;
                    if (Math.abs(finalX - existingX) < 45) {
                        positionOccupied = true;
                        finalX += gridSize;
                        if (finalX > maxX) {
                            finalX = 0 - gateHalfWidth;
                        }
                        break;
                    }
                }
                attempts++;
            }
            
            // **スタイル設定を改善**
            newGate.style.position = 'absolute';
            newGate.style.left = finalX + 'px';
            newGate.style.transform = 'translateY(-50%)';
            newGate.style.cursor = 'grab';
            newGate.style.zIndex = '10';
            newGate.style.display = 'flex';
            newGate.style.alignItems = 'center';
            newGate.style.justifyContent = 'center';
            newGate.style.textAlign = 'center';
            newGate.style.fontFamily = 'OpenSansRegular, sans-serif';
            newGate.style.fontWeight = 'medium';
            newGate.style.userSelect = 'none';
            newGate.style.border = 'none';
            newGate.style.borderRadius = '0px';
            newGate.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
            newGate.style.transition = 'all 0.2s ease';
            
            // ゲートタイプ別のスタイルを適用
            if (data.gateType === 'h-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#fa4d56';
                newGate.style.color = 'black';
                newGate.style.fontSize = '20px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'classical-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#4588ff';
                newGate.style.color = 'black';
                newGate.style.fontSize = '18px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'phase-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#bae6fe';
                newGate.style.color = 'black';
                newGate.style.fontSize = '18px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'other-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#a1a9af';
                newGate.style.color = 'black';
                newGate.style.fontSize = '16px';
                newGate.style.lineHeight = '40px';
            }
            
            // イベントリスナーを追加
            newGate.addEventListener('dragstart', handleDragStart);
            newGate.addEventListener('dragend', handleDragEnd);
            
            // ダブルクリックで削除
            newGate.addEventListener('dblclick', function() {
                newGate.remove();
            });
            
            // **内部要素のスタイルを調整**
            const pElements = newGate.querySelectorAll('p');
            pElements.forEach(p => {
                p.style.margin = '0';
                p.style.padding = '0';
                p.style.color = 'inherit';
                p.style.fontSize = 'inherit';
                p.style.lineHeight = 'inherit';
            });
            
            const svgElements = newGate.querySelectorAll('svg');
            svgElements.forEach(svg => {
                svg.style.width = '25px';
                svg.style.height = '25px';
                svg.style.display = 'inline-block';
                svg.style.verticalAlign = 'middle';
            });
            
            // 量子ビット線に配置
            qubitLine.style.position = 'relative';
            qubitLine.appendChild(newGate);
            
        } catch (error) {
            console.error('Drop error:', error);
        }
    }

    // ゴミ箱のドラッグイベント
    function handleTrashDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    }

    function handleTrashDragEnter(e) {
        e.preventDefault();
        e.target.closest('.trash-zone').classList.add('drag-over');
    }

    function handleTrashDragLeave(e) {
        const trashZone = e.target.closest('.trash-zone');
        if (trashZone && !trashZone.contains(e.relatedTarget)) {
            trashZone.classList.remove('drag-over');
        }
    }

    function handleTrashDrop(e) {
        e.preventDefault();
        e.target.closest('.trash-zone').classList.remove('drag-over');
        
        try {
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            
            // ドロップされたゲートのみ削除可能
            if (data.isFromDropped && draggedElement) {
                draggedElement.remove();
            }
            
        } catch (error) {
            // エラーハンドリング
        }
    }

    // パレットのゲートを初期化
    function initializePaletteGates() {
        const gates = document.querySelectorAll('.h-gate, .classical-gate, .phase-gate, .other-gate');
        
        gates.forEach((gate, index) => {
            // 既存のイベントリスナーを削除
            gate.removeEventListener('dragstart', handleDragStart);
            gate.removeEventListener('dragend', handleDragEnd);
            
            // 新しいイベントリスナーを追加
            gate.addEventListener('dragstart', handleDragStart);
            gate.addEventListener('dragend', handleDragEnd);
            
            // draggableが正しく設定されているか確認
            if (!gate.draggable) {
                gate.draggable = true;
            }
        });
    }

    // パブリックAPI
    return {
        initializeDragAndDrop: function() {
            initializePaletteGates();
            initializeDropZones();
        },

        reinitialize: function() {
            this.initializeDragAndDrop();
        },

        // 回路データを取得する関数
        getCircuitData: function() {
            const qubitLines = document.querySelectorAll('.qubit-line');
            const allGates = [];
            
            // すべてのゲートを収集してタイムスタンプ/位置でソート
            qubitLines.forEach((line, qubitIndex) => {
                const droppedGates = line.querySelectorAll('.dropped-gate');
                
                droppedGates.forEach((gate, gateIndex) => {
                    const leftPosition = parseInt(gate.style.left) || 0;
                    const gateType = getGateTypeFromElement(gate);
                    const timestamp = gate.dataset.timestamp ? parseInt(gate.dataset.timestamp) : Date.now() + gateIndex;
                    
                    // 実際のグリッドサイズを動的に計算（一般的には50px）
                    const gridSize = 50; // 多くのGUIでは50pxグリッド
                    const columnIndex = Math.round(leftPosition / gridSize);
                    
                    console.log(`🔍 Gate processing: ${gateType} at position ${leftPosition}px → column ${columnIndex} (qubit ${qubitIndex})`);
                    
                    allGates.push({
                        type: gateType,
                        position: leftPosition,
                        qubitIndex: qubitIndex,
                        timestamp: timestamp,
                        targetQubit: null, // 将来の2量子ビットゲート対応用
                        angle: null, // 将来の回転ゲート対応用
                        columnIndex: columnIndex, // X座標をカラムインデックスに変換
                        rowIndex: qubitIndex // Y座標（量子ビット行）
                    });
                });
            });
            
            // **物理順ソート：左から右（カラム）→上から下（行）**
            allGates.sort((a, b) => {
                // カラム順が最優先（左から右）
                if (a.columnIndex !== b.columnIndex) {
                    return a.columnIndex - b.columnIndex;
                }
                // 同じカラムなら行順（上から下）
                if (a.rowIndex !== b.rowIndex) {
                    return a.rowIndex - b.rowIndex;
                }
                // 最後にタイムスタンプ（配置順序の fallback）
                return a.timestamp - b.timestamp;
            });
            
            console.log('📊 JavaScript sorted gate order:');
            allGates.forEach((gate, index) => {
                console.log(`  ${index + 1}: ${gate.type} | Col: ${gate.columnIndex} | Row: ${gate.rowIndex} | Pos: ${gate.position}px | Qubit: ${gate.qubitIndex}`);
            });
            
            // 量子ビット別にグループ化
            const qubits = [];
            for (let i = 0; i < qubitLines.length; i++) {
                qubits.push({
                    index: i,
                    gates: []
                });
            }
            
            // ソートされたゲートを各量子ビットに割り当て
            allGates.forEach(gate => {
                if (gate.qubitIndex < qubits.length) {
                    qubits[gate.qubitIndex].gates.push({
                        type: gate.type,
                        position: gate.position,
                        targetQubit: gate.targetQubit,
                        angle: gate.angle
                    });
                }
            });
            
            return {
                qubits: qubits,
                globalGateOrder: allGates.map((gate, index) => ({
                    gateIndex: index + 1,
                    qubitIndex: gate.qubitIndex,
                    type: gate.type,
                    timestamp: gate.timestamp,
                    columnIndex: gate.columnIndex,
                    rowIndex: gate.rowIndex
                }))
            };
        }
    };

    // ドロップされたゲート要素からゲートタイプを取得
    function getGateTypeFromElement(element) {
        // テキストコンテンツを最初に確認（最も確実）
        const textContent = element.textContent?.trim() || '';
        console.log(`🔍 Detecting gate type from element:`, element, `text: "${textContent}"`);
        console.log(`📱 Element classes:`, Array.from(element.classList));
        console.log(`🏷️ Element innerHTML:`, element.innerHTML);
        
        // **I-gate専用の詳細検出**
        if (textContent === 'I' || textContent === '𝐈' || textContent === 'Identity') {
            console.log('✅ Detected I gate from text content');
            return 'I';
        }
        
        // **基本テキストベースの判定**
        if (textContent === 'H') return 'H';
        if (textContent === 'T†') return 'T†';
        if (textContent === 'S†') return 'S†';
        if (textContent === 'V†') return 'V†';
        if (textContent === 'T') return 'T';
        if (textContent === 'S') return 'S';
        if (textContent === 'V') return 'V';
        if (textContent === 'Y') return 'Y';
        if (textContent === 'Z') return 'Z';
        if (textContent === 'P') return 'P';
        if (textContent === 'Rx') return 'Rx';
        if (textContent === 'Ry') return 'Ry';
        if (textContent === 'Rz') return 'Rz';
        if (textContent === '|0⟩') return '|0⟩';
        
        // **HTMLコンテンツとクラスによる判定（テキストが無い場合）**
        const content = element.innerHTML || '';
        
        // I-gate専用のクラス判定
        if (element.classList.contains('i-gate') || 
            element.classList.contains('identity-gate') || 
            element.classList.contains('identity')) {
            console.log('✅ Detected I gate from class');
            return 'I';
        }
        
        // HTMLコンテンツからI-gateを検出
        if (content.includes('I') && !content.includes('H') && !content.includes('circle')) {
            console.log('✅ Detected I gate from innerHTML content');
            return 'I';
        }
        
        // その他のクラス名による判定
        if (element.classList.contains('h-gate')) {
            console.log('✅ Detected H gate from class');
            return 'H';
        }
        
        // SVGベースのXゲートを判定
        if (content.includes('<svg') || content.includes('viewBox') || 
            content.includes('circle') || content.includes('<line')) {
            console.log('✅ Detected X gate from SVG content');
            return 'X';
        }
        
        console.log('⚠️ Unknown gate type, defaulting to H');
        return 'H'; // デフォルト
    }
})();

// グローバル関数として露出（C#から呼び出し可能）
window.getCircuitData = function() {
    return JSON.stringify(window.dragAndDropInterop.getCircuitData());
};
</script>
