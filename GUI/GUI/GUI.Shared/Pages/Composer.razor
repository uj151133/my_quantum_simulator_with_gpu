@page "/composer"
@inject IJSRuntime JSRuntime
@using GUI.Shared.Services
@inject IQMDDSimulatorClient SimulatorClient
@inject NavigationManager NavigationManager
@using GUI.Shared.Models
@using System.Text.Json
@using Microsoft.AspNetCore.Components

<style>
.button {
    color: white;
    background-color: #512BD4;
    font-family: OpenSansRegular, sans-serif;
    font-size: 14px;
    padding: 10px 14px;
    min-height: 44px;
    min-width: 44px;
    border-width: 0px;
    border-radius: 8px;
}

.button:disabled {
    color: #141414;
    background-color: #C8C8C8;
}

.h-gate {
    position: relative;
    text-align: center;
    width: 40px;
    height: 40px;
    line-height: 40px;
    border: none;
    border-radius: 0px;
    background-color: #fa4d56;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.h-gate p {
    margin: 0;
    padding: 0;
}

.classical-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #4588ff;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.classical-gate p {
    margin: 0;
    padding: 0;
}

.phase-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #bae6fe;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.phase-gate p {
    margin: 0;
    padding: 0;
}

.other-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #a1a9af;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.other-gate p {
    margin: 0;
    padding: 0;
}

.trash-zone {
    position: static;
    transform: none;
    z-index: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: linear-gradient(145deg, #ff6b6b, #ee5a52);
    box-shadow: 
        0 8px 20px rgba(238, 90, 82, 0.3),
        inset 0 -3px 10px rgba(0, 0, 0, 0.1),
        inset 0 3px 10px rgba(255, 255, 255, 0.2);
    cursor: default;
    user-select: none;
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    overflow: hidden;
}

.trash-zone:hover {
    transform: scale(1.05);
    box-shadow: 
        0 12px 25px rgba(238, 90, 82, 0.4),
        inset 0 -3px 10px rgba(0, 0, 0, 0.1),
        inset 0 3px 10px rgba(255, 255, 255, 0.3);
}

.trash-zone.drag-over {
    transform: translateY(-50%) scale(1.1);
    background: linear-gradient(145deg, #27ae60, #229954);
    box-shadow: 
        0 20px 40px rgba(39, 174, 96, 0.5),
        inset 0 -3px 10px rgba(0, 0, 0, 0.2),
        inset 0 3px 10px rgba(255, 255, 255, 0.4);
    animation: pulse 0.6s infinite alternate;
}

@@keyframes pulse {
    0% { box-shadow: 0 20px 40px rgba(39, 174, 96, 0.5), inset 0 -3px 10px rgba(0, 0, 0, 0.2), inset 0 3px 10px rgba(255, 255, 255, 0.4); }
    100% { box-shadow: 0 25px 50px rgba(39, 174, 96, 0.7), inset 0 -5px 15px rgba(0, 0, 0, 0.3), inset 0 5px 15px rgba(255, 255, 255, 0.5); }
}

.trash-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 2;
}

.trash-icon {
    color: white;
    margin-bottom: 8px;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    transition: transform 0.2s ease;
}

.trash-zone:hover .trash-icon {
    transform: scale(1.1) rotateZ(5deg);
}

.trash-zone.drag-over .trash-icon {
    transform: scale(1.2) rotateZ(-5deg);
    animation: shake 0.3s ease-in-out infinite;
}

@@keyframes shake {
    0%, 100% { transform: scale(1.2) rotateZ(-5deg) translateX(0); }
    25% { transform: scale(1.2) rotateZ(-5deg) translateX(-2px); }
    75% { transform: scale(1.2) rotateZ(-5deg) translateX(2px); }
}

.trash-text {
    margin: 0;
    padding: 0;
    font-size: 9px;
    font-weight: 600;
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    text-align: center;
    line-height: 1.2;
    transition: all 0.2s ease;
}

.trash-zone:hover .trash-text {
    transform: scale(1.05);
}

.trash-glow {
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255, 107, 107, 0.3) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
}

.trash-zone:hover .trash-glow {
    opacity: 1;
}

.trash-zone.drag-over .trash-glow {
    background: radial-gradient(circle, rgba(39, 174, 96, 0.4) 0%, transparent 70%);
    opacity: 1;
}

.x-gate {
    width: 40px;
    height: 40px;
}

.x-gate:hover {
    filter: brightness(0.9);
}

.qubit-line {
    position: relative;
    flex-grow: 1;
    height: 1px;
    min-height: 30px;
    background-color: transparent;
    border: none;
    margin: 0;
    padding: 15px 0;
    background-image: 
        linear-gradient(to right, rgba(128, 128, 128, 0.2) 1px, transparent 1px);
    background-size: 50px 1px;
    background-position: 0 50%;
    transition: all 0.2s ease;
    cursor: crosshair;
    pointer-events: auto;
}

.qubit-line::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    background-color: currentColor;
    transform: translateY(-50%);
    z-index: 1;
}

.stepper {
    display: flex;
    align-items: center;
    gap: 8px;
}

.stepper-button {
    min-width: 44px;
    min-height: 44px;
    padding: 0;
    font-size: 20px;
    font-weight: bold;
}

.stepper-input {
    width: 80px;
    height: 44px;
    text-align: center;
    font-size: 16px;
    border: 1px solid #512BD4;
    border-radius: 8px;
    padding: 0 8px;
}

.stepper-input:focus {
    outline: none;
    box-shadow: 0 0 0 0.1rem white, 0 0 0 0.25rem #258cfb;
}

.gate-section {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 3px;
    margin-bottom: 5px;
}

.gate-section label {
    color: #333;
    font-weight: 600;
    margin-bottom: 2px;
    font-size: 13px;
}

.gate-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
}

.horizontal-container {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-right: 160px;
}

.vertical-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
}

.dragging {
    opacity: 0.5;
    transform: scale(0.9);
    transition: all 0.2s ease;
}

.dropped-gate {
    min-width: 30px !important;
    min-height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-size: 14px !important;
    border-radius: 0px !important;
    user-select: none !important;
    text-align: center !important;
    line-height: normal !important;
    font-family: OpenSansRegular, sans-serif !important;
    font-weight: medium !important;
    border: none !important;
    cursor: grab !important;
    position: absolute !important;
    transform: translateY(-50%) !important;
    z-index: 10 !important;
    pointer-events: auto !important;
    transition: all 0.2s ease !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

.dropped-gate.h-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #fa4d56 !important;
    color: black !important;
    font-size: 20px !important;
    line-height: 40px !important;
}

.dropped-gate.classical-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #4588ff !important;
    color: black !important;
    font-size: 18px !important;
    line-height: 40px !important;
}

.dropped-gate.phase-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #bae6fe !important;
    color: black !important;
    font-size: 18px !important;
    line-height: 40px !important;
}

.dropped-gate.other-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #a1a9af !important;
    color: black !important;
    font-size: 16px !important;
    line-height: 40px !important;
}

.dropped-gate:hover {
    opacity: 0.8 !important;
    cursor: grab !important;
    filter: brightness(1.1) !important;
    transform: translateY(-50%) scale(1.05) !important;
}

.dropped-gate.dragging {
    opacity: 0.5 !important;
    cursor: grabbing !important;
    transform: translateY(-50%) scale(0.9) !important;
    transition: all 0.2s ease !important;
    z-index: 1000 !important;
}

.qubit-line:hover {
    height: 3px !important;
    background-color: #512BD4 !important;
    transition: all 0.2s ease;
}

.gate-palette {
    background-color: #f5f5f5;
    padding: 8px;
    border-radius: 6px;
    border: 2px dashed #ccc;
    min-width: 400px;
}

.gate-palette h3 {
    margin-top: 0;
    margin-bottom: 5px;
    color: #333;
    font-size: 18px;
}

.usage-hint {
    font-size: 12px;
    color: #666;
    margin: -3px 0 5px 0;
    padding: 8px;
    background-color: rgba(81, 43, 212, 0.1);
    border-radius: 4px;
    border-left: 3px solid #512BD4;
}

@@media (prefers-color-scheme: dark) {
    .button {
        color: #242424;
        background-color: #ac99ea;
    }

    .button:disabled {
        color: #c8c8c8;
        background-color: #404040;
    }

    .stepper-input {
        background-color: #242424;
        color: #fff;
        border-color: #ac99ea;
    }

    .gate-palette {
        background-color: #2d2d2d;
        border-color: #555;
    }

    .gate-palette h3 {
        color: #fff;
    }

    .usage-hint {
        color: #ccc;
        background-color: rgba(172, 153, 234, 0.1);
        border-left-color: #ac99ea;
    }

    .gate-palette label {
        color: #ccc;
    }

    .gate-section label {
        color: #ccc;
        font-size: 13px;
    }

    .qubit-line:hover {
        background-color: #ac99ea !important;
    }
}

.dropped-gate p {
    margin: 0 !important;
    padding: 0 !important;
    color: inherit !important;
    font-size: inherit !important;
    line-height: inherit !important;
}

.dropped-gate svg {
    width: 25px !important;
    height: 25px !important;
    display: inline-block !important;
    vertical-align: middle !important;
}

.dropped-gate sup {
    font-size: 0.7em !important;
    vertical-align: super !important;
    line-height: 0 !important;
}

.dropped-gate sub {
    font-size: 0.7em !important;
    vertical-align: sub !important;
    line-height: 0 !important;
}

.header-container {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 20px;
    gap: 30px;
}

.title-section {
    flex: 1;
}

.controls-section {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 15px;
    margin-top: 10px;
}
</style>

<div class="header-container">
    <div class="title-section">
        <h1>Composer</h1>
        <div class="controls-section">
            <div class="stepper-section">
                <p role="status">number of qubits: @currentCount</p>
                <div class="stepper">
                    <button class="button stepper-button" @onclick="DecrementCount">-</button>
                    <input type="number" 
                        class="stepper-input" 
                        value="@currentCount"
                        @onchange="OnInputChange" />
                    <button class="button stepper-button" @onclick="IncrementCount">+</button>
                </div>
            </div>
            
            <div style="display: flex; align-items: center; gap: 20px;">
                <!-- ã‚´ãƒŸç®±ã‚¨ãƒªã‚¢ -->
                <div class="trash-zone" title="ã“ã“ã«ã‚²ãƒ¼ãƒˆã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å‰Šé™¤">
                    <div class="trash-container">
                        <svg class="trash-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path d="M19 7H16V6C16 4.89 15.11 4 14 4H10C8.89 4 8 4.89 8 6V7H5C4.45 7 4 7.45 4 8S4.45 9 5 9H6V19C6 20.11 6.89 21 8 21H16C17.11 21 18 20.11 18 19V9H19C19.55 9 20 8.55 20 8S19.55 7 19 7ZM10 6H14V7H10V6ZM16 19H8V9H16V19Z" fill="currentColor"/>
                            <path d="M10 11V17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            <path d="M14 11V17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        <p class="trash-text">ã‚²ãƒ¼ãƒˆã‚’å‰Šé™¤</p>
                        <div class="trash-glow"></div>
                    </div>
                </div>
                
                <!-- Runãƒœã‚¿ãƒ³ -->
                <button class="button" @onclick="SimulateCircuit" disabled="@isSimulating">
                    @if (isSimulating)
                    {
                        <span>ğŸ”„ Running...</span>
                    }
                    else
                    {
                        <span>â–¶ï¸ Run</span>
                    }
                </button>
            </div>
        </div>
    </div>

    <div class="vertical-container gate-palette">
        <h3>é‡å­ã‚²ãƒ¼ãƒˆãƒ‘ãƒ¬ãƒƒãƒˆ</h3>
        <p class="usage-hint">ğŸ’¡ ã‚²ãƒ¼ãƒˆã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦é‡å­ãƒ“ãƒƒãƒˆç·šä¸Šã«é…ç½®ã§ãã¾ã™ã€‚ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§å‰Šé™¤ã€ã‚´ãƒŸç®±ã«ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚‚å‰Šé™¤ã§ãã¾ã™ã€‚</p>        <div class="gate-section">
            <label>åŸºæœ¬ã‚²ãƒ¼ãƒˆ:</label>
            <div class="gate-row">
                <div class="h-gate" draggable="true" title="Hadamardã‚²ãƒ¼ãƒˆ">H</div>
            </div>
        </div>

        <div class="gate-section">
            <label>ã‚¯ãƒ©ã‚·ã‚«ãƒ«ã‚²ãƒ¼ãƒˆ:</label>
            <div class="gate-row">
                <div class="classical-gate" draggable="true" title="Xã‚²ãƒ¼ãƒˆï¼ˆPauliã‚²ãƒ¼ãƒˆï¼‰">
                    <svg class="x-gate" viewBox="0 0 25 25" width="25" height="25">
                        <circle cx="12.5" cy="12.5" r="6.25" stroke="black" stroke-width="1" fill="none"/>
                        <line x1="6.25" y1="12.5" x2="18.75" y2="12.5" stroke="black" stroke-width="1"/>
                        <line x1="12.5" y1="6.25" x2="12.5" y2="18.75" stroke="black" stroke-width="1"/>
                    </svg>
                </div>
                <div class="classical-gate" draggable="true" title="Identityã‚²ãƒ¼ãƒˆ">
                    <p>I</p>
                </div>
            </div>
        </div>

        <div class="gate-section">
            <label>ä½ç›¸ã‚²ãƒ¼ãƒˆ:</label>
            <div class="gate-row">
                <div class="phase-gate" draggable="true" title="Tã‚²ãƒ¼ãƒˆ">
                    <p>T</p>
                </div>
                <div class="phase-gate" draggable="true" title="Tâ€ ã‚²ãƒ¼ãƒˆ">
                    <p>T<sup>â€ </sup></p>
                </div>
                <div class="phase-gate" draggable="true" title="Sã‚²ãƒ¼ãƒˆ">
                    <p>S</p>
                </div>
                <div class="phase-gate" draggable="true" title="Sâ€ ã‚²ãƒ¼ãƒˆ">
                    <p>S<sup>â€ </sup></p>
                </div>
                <div class="phase-gate" draggable="true" title="Vã‚²ãƒ¼ãƒˆ">
                    <p>V</p>
                </div>
                <div class="phase-gate" draggable="true" title="Vâ€ ã‚²ãƒ¼ãƒˆ">
                    <p>V<sup>â€ </sup></p>
                </div>
                <div class="phase-gate" draggable="true" title="Yã‚²ãƒ¼ãƒˆ">
                    <p>Y</p>
                </div>
                <div class="phase-gate" draggable="true" title="Zã‚²ãƒ¼ãƒˆ">
                    <p>Z</p>
                </div>
                <div class="phase-gate" draggable="true" title="ä½ç›¸ã‚²ãƒ¼ãƒˆ">
                    <p>P</p>
                </div>
                <div class="phase-gate" draggable="true" title="å›è»¢Xã‚²ãƒ¼ãƒˆ">
                    <p>Rx</p>
                </div>
                <div class="phase-gate" draggable="true" title="å›è»¢Yã‚²ãƒ¼ãƒˆ">
                    <p>Ry</p>
                </div>
                <div class="phase-gate" draggable="true" title="å›è»¢Zã‚²ãƒ¼ãƒˆ">
                    <p>Rz</p>
                </div>
            </div>
        </div>

        <div class="gate-section">
            <label>ãã®ä»–:</label>
            <div class="gate-row">
                <div class="other-gate" draggable="true" title="åˆæœŸçŠ¶æ…‹">
                    <p>|0âŸ©</p>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private int currentCount = 2;
    private bool isSimulating = false;
    private GUI.Shared.Models.SimulationResult? lastResult = null; // **æ˜ç¤ºçš„ã«åå‰ç©ºé–“ã‚’æŒ‡å®š**
    private string statusMessage = "";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {
            if (firstRender)
            {
                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰JavaScriptã‚’å‘¼ã³å‡ºã™
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.initializeDragAndDrop");
            }
            else
            {
                // é‡å­ãƒ“ãƒƒãƒˆæ•°ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ã«ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ã‚’å†åˆæœŸåŒ–
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
        }
        catch (Exception ex)
        {
            // JavaScripté–¢æ•°ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯ç„¡è¦–
            Console.WriteLine($"JavaScript function not yet available: {ex.Message}");
        }
    }

    private async Task SimulateCircuit()
    {
        isSimulating = true;
        statusMessage = "ğŸ”„ å›è·¯ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...";
        StateHasChanged();

        try
        {
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            if (!await SimulatorClient.IsSimulatorAvailableAsync())
            {
                statusMessage = "âŒ QMDD Simulator is not available. Please start the simulator with -s flag.";
                return;
            }

            // JavaScriptã‹ã‚‰ç¾åœ¨ã®å›è·¯ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            var circuitDataJson = await JSRuntime.InvokeAsync<string>("getCircuitData");
            
            if (string.IsNullOrEmpty(circuitDataJson))
            {
                statusMessage = "âš ï¸ No circuit data found. Please add some gates first.";
                return;
            }

            var circuitData = JsonSerializer.Deserialize<CircuitData>(circuitDataJson, 
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (circuitData == null)
            {
                statusMessage = "âš ï¸ Failed to parse circuit data. Please try again.";
                return;
            }

            var request = BuildCircuitRequest(circuitData);
            
            if (request.Gates.Count == 0)
            {
                statusMessage = "âš ï¸ No gates in circuit. Please add some gates first.";
                return;
            }

            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
            statusMessage = $"ğŸš€ Simulating circuit with {request.Gates.Count} gates on {request.NumQubits} qubits...";
            StateHasChanged();

            lastResult = await SimulatorClient.SimulateCircuitAsync(request);
            
            if (lastResult.Success)
            {
                statusMessage = $"âœ… Simulation completed successfully in {lastResult.ExecutionTime:F2}ms";
                
                // **SaveResultForHeartbeatã¨åŒã˜å½¢å¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹æˆ**
                var simulationData = new
                {
                    Success = lastResult.Success,
                    GateCount = request.Gates.Count,
                    ExecutionTime = lastResult.ExecutionTime,
                    Gates = request.Gates.Select((gate, index) => new
                    {
                        GateNumber = index + 1,
                        Type = gate.Type,
                        Label = $"Gate {index + 1} ({gate.Type})",
                        Qubits = gate.Qubits,
                        ControlQubits = gate.ControlQubits
                    }).ToList(),
                    Timestamp = DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"),
                    FinalState = lastResult.FinalState,
                    DetailedLog = lastResult.GateExecutionLogs.Select(log => new
                    {
                        GateNumber = log.GateNumber,
                        GateLabel = log.GateLabel,
                        GateType = log.GateType,
                        Qubits = log.Qubits,
                        ControlQubits = log.ControlQubits,
                        CurrentGate = new
                        {
                            Weight = log.CurrentGate.Weight,
                            Key = log.CurrentGate.Key,
                            IsTerminal = log.CurrentGate.IsTerminal
                        },
                        CurrentState = new
                        {
                            Weight = log.CurrentState.Weight,
                            Key = log.CurrentState.Key,
                            IsTerminal = log.CurrentState.IsTerminal
                        }
                    }).ToList()
                };

                Console.WriteLine($"ğŸ¯ Composer saving result - DetailedLog count: {simulationData.DetailedLog.Count()}");

                await JSRuntime.InvokeVoidAsync("sessionStorage.setItem", "simulationResult", 
                    JsonSerializer.Serialize(simulationData, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));
                
                Console.WriteLine("ğŸ’¾ Composer result saved to session storage");
                
                // Heartbeatãƒšãƒ¼ã‚¸ã«ç§»å‹•
                NavigationManager.NavigateTo("/heartbeat");
            }
            else
            {
                statusMessage = $"âŒ Simulation failed: {lastResult.ErrorMessage}";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"ğŸ’¥ Error: {ex.Message}";
        }
        finally
        {
            isSimulating = false;
            StateHasChanged();
        }
    }

    private CircuitRequest BuildCircuitRequest(CircuitData? circuitData)
    {
        var request = new CircuitRequest
        {
            NumQubits = currentCount, // **ç¾åœ¨è¨­å®šã•ã‚Œã¦ã„ã‚‹é‡å­ãƒ“ãƒƒãƒˆæ•°ã‚’æ­£ã—ãä½¿ç”¨**
            Gates = new List<GateCommand>()
        };

        if (circuitData?.Qubits == null) return request;

        // **ã‚°ãƒ­ãƒ¼ãƒãƒ«é †åºãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯å¿…ãšãã‚Œã‚’ä½¿ç”¨ï¼ˆæ™‚ç³»åˆ—é †åºï¼‰**
        if (circuitData.GlobalGateOrder != null && circuitData.GlobalGateOrder.Count > 0)
        {
            Console.WriteLine($"ğŸ”„ Using global gate order: {circuitData.GlobalGateOrder.Count} gates");
            
            // **ç‰©ç†é †ã‚½ãƒ¼ãƒˆå¾Œã®ã‚²ãƒ¼ãƒˆé †åºã‚’ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›**
            var sortedGates = circuitData.GlobalGateOrder
                .OrderBy(g => g.ColumnIndex)
                .ThenBy(g => g.RowIndex)
                .ThenBy(g => g.GateIndex)
                .ToList();
            
            Console.WriteLine("ğŸ“Š Gate execution order (Columnâ†’Rowâ†’Index):");
            foreach (var gate in sortedGates)
            {
                Console.WriteLine($"  Gate: {gate.Type} | Column: {gate.ColumnIndex} | Row: {gate.RowIndex} | Qubit: {gate.QubitIndex}");
            }
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«é †åºã«å¾“ã£ã¦ã‚²ãƒ¼ãƒˆã‚’å‡¦ç†ï¼ˆå›è·¯ã®ç‰©ç†é †ï¼šå·¦ã‹ã‚‰å³â†’ä¸Šã‹ã‚‰ä¸‹ï¼‰
            foreach (var globalGate in sortedGates)
            {
                Console.WriteLine($"ğŸ¯ Processing gate {globalGate.GateIndex}: {globalGate.Type} on qubit {globalGate.QubitIndex}");
                
                if (globalGate.QubitIndex >= 0 && globalGate.QubitIndex < currentCount)
                {
                    var gateCommand = new GateCommand
                    {
                        Type = ConvertGateType(globalGate.Type),
                        Qubits = new List<int> { globalGate.QubitIndex }
                    };
                    
                    Console.WriteLine($"âœ… Added gate: {gateCommand.Type} on qubit {globalGate.QubitIndex}");
                    request.Gates.Add(gateCommand);
                }
                else
                {
                    Console.WriteLine($"âš ï¸ Skipping gate on invalid qubit {globalGate.QubitIndex}");
                }
            }
        }
        else
        {
            // **å¾“æ¥é€šã‚Šã®å‡¦ç†ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ï¼‰**
            for (int qubitIndex = 0; qubitIndex < Math.Min(circuitData.Qubits.Count, currentCount); qubitIndex++)
            {
                var qubitGates = circuitData.Qubits[qubitIndex].Gates;
                
                if (qubitGates == null) continue;
                
                foreach (var gate in qubitGates)
                {
                    if (gate?.Type == null) continue;
                    
                    var gateCommand = new GateCommand
                    {
                        Type = ConvertGateType(gate.Type),
                        Qubits = new List<int> { qubitIndex }
                    };
                    
                    // 2é‡å­ãƒ“ãƒƒãƒˆã‚²ãƒ¼ãƒˆã®å ´åˆ
                    if (gate.Type == "CNOT" || gate.Type == "CZ")
                    {
                        if (gate.TargetQubit.HasValue && gate.TargetQubit.Value < currentCount)
                        {
                            gateCommand.ControlQubits = new List<int> { qubitIndex };
                            gateCommand.Qubits = new List<int> { gate.TargetQubit.Value };
                        }
                    }
                    
                    // å›è»¢ã‚²ãƒ¼ãƒˆã®è§’åº¦è¨­å®š
                    if (gate.Angle.HasValue)
                    {
                        gateCommand.Angle = gate.Angle.Value;
                    }
                    
                    request.Gates.Add(gateCommand);
                }
            }
        }

        return request;
    }

    private string ConvertGateType(string guiGateType)
    {
        // GUIã§ã®ã‚²ãƒ¼ãƒˆè¡¨ç¤ºåã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ä½¿ç”¨ã•ã‚Œã‚‹åå‰ã«å¤‰æ›
        return guiGateType switch
        {
            "H" => "H",
            "X" => "X",
            "I" => "I",
            "T" => "T",
            "Tâ€ " => "Tdg",
            "S" => "S", 
            "Sâ€ " => "Sdg",
            "V" => "V",
            "Vâ€ " => "Vdg",
            "Y" => "Y",
            "Z" => "Z",
            "P" => "P",
            "Rx" => "RX",
            "Ry" => "RY",
            "Rz" => "RZ",
            "|0âŸ©" => "Reset",
            _ => guiGateType
        };
    }

    private string GenerateGateLabel(string gateType, List<int> qubits, List<int>? controlQubits = null)
    {
        var label = gateType switch
        {
            "H" => "Hadamard Gate",
            "X" => "Pauli-X Gate", 
            "Y" => "Pauli-Y Gate",
            "Z" => "Pauli-Z Gate",
            "I" => "Identity Gate",
            "T" => "T Gate",
            "Tdg" => "Tâ€  Gate (T-dagger)",
            "S" => "S Gate",
            "Sdg" => "Sâ€  Gate (S-dagger)",
            "V" => "V Gate",
            "Vdg" => "Vâ€  Gate (V-dagger)",
            "P" => "Phase Gate",
            "RX" => "Rotation-X Gate",
            "RY" => "Rotation-Y Gate",
            "RZ" => "Rotation-Z Gate",
            "CNOT" => "Controlled-X Gate",
            "CZ" => "Controlled-Z Gate",
            "Reset" => "Reset to |0âŸ©",
            _ => $"{gateType} Gate"
        };

        // é‡å­ãƒ“ãƒƒãƒˆæƒ…å ±ã‚’è¿½åŠ 
        if (controlQubits?.Count > 0)
        {
            return $"{label} [Control: {string.Join(",", controlQubits)} â†’ Target: {string.Join(",", qubits)}]";
        }
        else
        {
            return $"{label} [Qubit: {string.Join(",", qubits)}]";
        }
    }

    private int GetNumQubits()
    {
        return currentCount;
    }

    private async Task IncrementCount()
    {
        currentCount++;
        StateHasChanged();
        try
        {
            await Task.Delay(50); // **DOMæ›´æ–°ã‚’ç¢ºå®Ÿã«å¾…ã¤**
            await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"JavaScript function not available: {ex.Message}");
        }
    }

    private async Task DecrementCount()
    {
        if (currentCount > 1) // **æœ€å°å€¤ã‚’1ã«è¨­å®š**
        {
            currentCount--;
            StateHasChanged();
            try
            {
                await Task.Delay(50); // **DOMæ›´æ–°ã‚’ç¢ºå®Ÿã«å¾…ã¤**
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript function not available: {ex.Message}");
            }
        }
    }

    private async Task OnInputChange(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int value) && value >= 1) // **æœ€å°å€¤ã‚’1ã«è¨­å®š**
        {
            currentCount = value;
            StateHasChanged();
            try
            {
                await Task.Delay(50); // **DOMæ›´æ–°ã‚’ç¢ºå®Ÿã«å¾…ã¤**
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript function not available: {ex.Message}");
            }
        }
    }
}

<!-- é‡å­å›è·¯ã‚¨ãƒªã‚¢ -->
<div class="circuit-area">
@for (int i = 0; i < currentCount; i++)
{
    <div style="display: flex; align-items: center; margin: 15px 0;">
        <span style="margin-right: 20px; font-size: 20px;">q<sub>@i</sub></span>
        <div class="qubit-line"></div>
    </div>
}
</div>

<!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
@if (!string.IsNullOrEmpty(statusMessage))
{
    <div style="margin: 20px 0; padding: 10px; background-color: @(lastResult?.Success == true ? "#d4edda" : "#f8d7da"); border-radius: 4px; border: 1px solid @(lastResult?.Success == true ? "#c3e6cb" : "#f5c6cb");">
        @statusMessage
    </div>
}

<script>
// ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½ã®åˆæœŸåŒ–
window.dragAndDropInterop = (function() {
    
    // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆå¤‰æ•°
    let draggedElement = null;
    let isFromDroppedGate = false;
    let isDragging = false; // **é‡è¤‡é˜²æ­¢ãƒ•ãƒ©ã‚°ã‚’è¿½åŠ **

    // ã‚²ãƒ¼ãƒˆã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—
    function getGateContent(element) {
        // SVGãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        if (element.querySelector('svg')) {
            // SVGã‚’å«ã‚€å ´åˆã¯å…¨ä½“ã®HTMLã‚’ä¿æŒ
            return {
                type: 'html',
                content: element.innerHTML
            };
        } else if (element.querySelector('p')) {
            // pã‚¿ã‚°ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã®HTMLã‚’ä¿æŒ
            return {
                type: 'html',
                content: element.innerHTML
            };
        } else {
            // ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å ´åˆ
            return {
                type: 'text',
                content: element.textContent || 'H'
            };
        }
    }

    // ã‚²ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã‚’å–å¾—
    function getGateType(element) {
        const classes = element.className.split(' ');
        return classes.find(cls => cls.endsWith('-gate')) || 'h-gate';
    }

    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
    function handleDragStart(e) {
        if (isDragging) { // **æ—¢ã«ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®å ´åˆã¯ç„¡è¦–**
            e.preventDefault();
            return;
        }
        
        isDragging = true; // **ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã‚’ãƒãƒ¼ã‚¯**
        draggedElement = e.target;
        isFromDroppedGate = e.target.classList.contains('dropped-gate');
        
        e.target.classList.add('dragging');
        
        // ã‚²ãƒ¼ãƒˆã®æƒ…å ±ã‚’ä¿å­˜
        const gateContent = getGateContent(e.target);
        const gateType = getGateType(e.target);
        
        const dragData = {
            gateType: gateType,
            isFromDropped: isFromDroppedGate,
            sourceId: isFromDroppedGate ? e.target.id || Date.now().toString() : null,
            contentType: gateContent.type,
            content: gateContent.content
        };
        
        e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
        e.dataTransfer.effectAllowed = isFromDroppedGate ? 'move' : 'copy';
    }

    // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
    function handleDragEnd(e) {
        e.target.classList.remove('dragging');
        draggedElement = null;
        isFromDroppedGate = false;
        
        // **å°‘ã—é…å»¶ã—ã¦ã‹ã‚‰ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆé‡è¤‡é˜²æ­¢ï¼‰**
        setTimeout(() => {
            isDragging = false;
        }, 100);
    }

    // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ã®åˆæœŸåŒ–
    function initializeDropZones() {
        // é‡å­ãƒ“ãƒƒãƒˆç·šã®ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³
        const qubitLines = document.querySelectorAll('.qubit-line');
        
        qubitLines.forEach((line, index) => {
            // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
            line.removeEventListener('dragover', handleQubitDragOver);
            line.removeEventListener('drop', handleQubitDrop);
            line.removeEventListener('dragenter', handleQubitDragEnter);
            line.removeEventListener('dragleave', handleQubitDragLeave);
            
            // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            line.addEventListener('dragover', handleQubitDragOver);
            line.addEventListener('drop', handleQubitDrop);
            line.addEventListener('dragenter', handleQubitDragEnter);
            line.addEventListener('dragleave', handleQubitDragLeave);
            
            // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ãƒ†ã‚¹ãƒˆ
            line.style.minHeight = '20px';
            line.style.position = 'relative';
        });

        // ã‚´ãƒŸç®±ã®ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³
        const trashZone = document.querySelector('.trash-zone');
        if (trashZone) {
            trashZone.removeEventListener('dragover', handleTrashDragOver);
            trashZone.removeEventListener('drop', handleTrashDrop);
            trashZone.removeEventListener('dragenter', handleTrashDragEnter);
            trashZone.removeEventListener('dragleave', handleTrashDragLeave);
            
            trashZone.addEventListener('dragover', handleTrashDragOver);
            trashZone.addEventListener('drop', handleTrashDrop);
            trashZone.addEventListener('dragenter', handleTrashDragEnter);
            trashZone.addEventListener('dragleave', handleTrashDragLeave);
        }
    }

    // é‡å­ãƒ“ãƒƒãƒˆç·šã®ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆ
    function handleQubitDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = isFromDroppedGate ? 'move' : 'copy';
    }

    function handleQubitDragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        const target = e.target.closest('.qubit-line') || e.target;
        target.style.backgroundColor = '#512BD4';
        target.style.height = '3px';
    }

    function handleQubitDragLeave(e) {
        e.stopPropagation();
        const target = e.target.closest('.qubit-line') || e.target;
        // å­è¦ç´ ã‹ã‚‰ã®leaveã‚¤ãƒ™ãƒ³ãƒˆã‚’ç„¡è¦–
        if (!target.contains(e.relatedTarget)) {
            target.style.backgroundColor = '';
            target.style.height = '1px';
        }
    }

    function handleQubitDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // **æ—¢ã«å‡¦ç†ä¸­ã®å ´åˆã¯ç„¡è¦–**
        if (!isDragging) {
            return;
        }
        
        const target = e.target.closest('.qubit-line') || e.target;
        target.style.backgroundColor = '';
        target.style.height = '1px';
        
        try {
            const dragDataString = e.dataTransfer.getData('text/plain');
            
            if (!dragDataString) {
                return;
            }
            
            const data = JSON.parse(dragDataString);
            
            const qubitLine = target;
            
            // ç§»å‹•ã®å ´åˆã¯å…ƒã®è¦ç´ ã‚’å‰Šé™¤
            if (data.isFromDropped && draggedElement) {
                draggedElement.remove();
            }
            
            // **é‡è¤‡ãƒã‚§ãƒƒã‚¯: åŒã˜ãƒ‡ãƒ¼ã‚¿ã§æ—¢å­˜ã®ã‚²ãƒ¼ãƒˆãŒã‚ã‚‹å ´åˆã¯ä½œæˆã—ãªã„**
            const existingGatesCount = qubitLine.querySelectorAll('.dropped-gate').length;
            
            // æ–°ã—ã„ã‚²ãƒ¼ãƒˆè¦ç´ ã‚’ä½œæˆ
            const newGate = document.createElement('div');
            newGate.className = data.gateType + ' dropped-gate';
            newGate.draggable = true;
            newGate.id = 'gate-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            
            // **ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¿½åŠ ï¼ˆé…ç½®é †åºã®è¿½è·¡ç”¨ï¼‰**
            newGate.dataset.timestamp = Date.now().toString();
            
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¨­å®š
            if (data.contentType === 'html') {
                newGate.innerHTML = data.content;
            } else {
                newGate.textContent = data.content;
            }
            
            // ãƒ‰ãƒ­ãƒƒãƒ—ä½ç½®ã‚’è¨ˆç®—ï¼ˆã‚°ãƒªãƒƒãƒ‰ã®ç¸¦ç·šã«ã‚¹ãƒŠãƒƒãƒ—ï¼‰
            const rect = qubitLine.getBoundingClientRect();
            const dropX = e.clientX - rect.left;
            const gridSize = 50;
            const gateWidth = 40;
            const gateHalfWidth = gateWidth / 2;
            
            // æœ€ã‚‚è¿‘ã„ç¸¦ç·šã®ä½ç½®ã«ã‚¹ãƒŠãƒƒãƒ—
            const snappedX = Math.round(dropX / gridSize) * gridSize;
            const adjustedX = snappedX - gateHalfWidth;
            const maxX = qubitLine.offsetWidth - gateWidth;
            let finalX = Math.max(0 - gateHalfWidth, Math.min(adjustedX, maxX));
            
            // **é‡è¤‡ãƒã‚§ãƒƒã‚¯ã‚’æ”¹å–„**
            const existingGates = qubitLine.querySelectorAll('.dropped-gate');
            let positionOccupied = true;
            let attempts = 0;
            
            while (positionOccupied && attempts < 20) {
                positionOccupied = false;
                for (const existingGate of existingGates) {
                    const existingX = parseInt(existingGate.style.left) || 0;
                    if (Math.abs(finalX - existingX) < 45) {
                        positionOccupied = true;
                        finalX += gridSize;
                        if (finalX > maxX) {
                            finalX = 0 - gateHalfWidth;
                        }
                        break;
                    }
                }
                attempts++;
            }
            
            // **ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚’æ”¹å–„**
            newGate.style.position = 'absolute';
            newGate.style.left = finalX + 'px';
            newGate.style.transform = 'translateY(-50%)';
            newGate.style.cursor = 'grab';
            newGate.style.zIndex = '10';
            newGate.style.display = 'flex';
            newGate.style.alignItems = 'center';
            newGate.style.justifyContent = 'center';
            newGate.style.textAlign = 'center';
            newGate.style.fontFamily = 'OpenSansRegular, sans-serif';
            newGate.style.fontWeight = 'medium';
            newGate.style.userSelect = 'none';
            newGate.style.border = 'none';
            newGate.style.borderRadius = '0px';
            newGate.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
            newGate.style.transition = 'all 0.2s ease';
            
            // ã‚²ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—åˆ¥ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
            if (data.gateType === 'h-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#fa4d56';
                newGate.style.color = 'black';
                newGate.style.fontSize = '20px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'classical-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#4588ff';
                newGate.style.color = 'black';
                newGate.style.fontSize = '18px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'phase-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#bae6fe';
                newGate.style.color = 'black';
                newGate.style.fontSize = '18px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'other-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#a1a9af';
                newGate.style.color = 'black';
                newGate.style.fontSize = '16px';
                newGate.style.lineHeight = '40px';
            }
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            newGate.addEventListener('dragstart', handleDragStart);
            newGate.addEventListener('dragend', handleDragEnd);
            
            // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§å‰Šé™¤
            newGate.addEventListener('dblclick', function() {
                newGate.remove();
            });
            
            // **å†…éƒ¨è¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’èª¿æ•´**
            const pElements = newGate.querySelectorAll('p');
            pElements.forEach(p => {
                p.style.margin = '0';
                p.style.padding = '0';
                p.style.color = 'inherit';
                p.style.fontSize = 'inherit';
                p.style.lineHeight = 'inherit';
            });
            
            const svgElements = newGate.querySelectorAll('svg');
            svgElements.forEach(svg => {
                svg.style.width = '25px';
                svg.style.height = '25px';
                svg.style.display = 'inline-block';
                svg.style.verticalAlign = 'middle';
            });
            
            // é‡å­ãƒ“ãƒƒãƒˆç·šã«é…ç½®
            qubitLine.style.position = 'relative';
            qubitLine.appendChild(newGate);
            
        } catch (error) {
            console.error('Drop error:', error);
        }
    }

    // ã‚´ãƒŸç®±ã®ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆ
    function handleTrashDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    }

    function handleTrashDragEnter(e) {
        e.preventDefault();
        e.target.closest('.trash-zone').classList.add('drag-over');
    }

    function handleTrashDragLeave(e) {
        const trashZone = e.target.closest('.trash-zone');
        if (trashZone && !trashZone.contains(e.relatedTarget)) {
            trashZone.classList.remove('drag-over');
        }
    }

    function handleTrashDrop(e) {
        e.preventDefault();
        e.target.closest('.trash-zone').classList.remove('drag-over');
        
        try {
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            
            // ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã‚²ãƒ¼ãƒˆã®ã¿å‰Šé™¤å¯èƒ½
            if (data.isFromDropped && draggedElement) {
                draggedElement.remove();
            }
            
        } catch (error) {
            // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        }
    }

    // ãƒ‘ãƒ¬ãƒƒãƒˆã®ã‚²ãƒ¼ãƒˆã‚’åˆæœŸåŒ–
    function initializePaletteGates() {
        const gates = document.querySelectorAll('.h-gate, .classical-gate, .phase-gate, .other-gate');
        
        gates.forEach((gate, index) => {
            // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
            gate.removeEventListener('dragstart', handleDragStart);
            gate.removeEventListener('dragend', handleDragEnd);
            
            // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            gate.addEventListener('dragstart', handleDragStart);
            gate.addEventListener('dragend', handleDragEnd);
            
            // draggableãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            if (!gate.draggable) {
                gate.draggable = true;
            }
        });
    }

    // ãƒ‘ãƒ–ãƒªãƒƒã‚¯API
    return {
        initializeDragAndDrop: function() {
            initializePaletteGates();
            initializeDropZones();
        },

        reinitialize: function() {
            this.initializeDragAndDrop();
        },

        // å›è·¯ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹é–¢æ•°
        getCircuitData: function() {
            const qubitLines = document.querySelectorAll('.qubit-line');
            const allGates = [];
            
            // ã™ã¹ã¦ã®ã‚²ãƒ¼ãƒˆã‚’åé›†ã—ã¦ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—/ä½ç½®ã§ã‚½ãƒ¼ãƒˆ
            qubitLines.forEach((line, qubitIndex) => {
                const droppedGates = line.querySelectorAll('.dropped-gate');
                
                droppedGates.forEach((gate, gateIndex) => {
                    const leftPosition = parseInt(gate.style.left) || 0;
                    const gateType = getGateTypeFromElement(gate);
                    const timestamp = gate.dataset.timestamp ? parseInt(gate.dataset.timestamp) : Date.now() + gateIndex;
                    
                    // å®Ÿéš›ã®ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã‚’å‹•çš„ã«è¨ˆç®—ï¼ˆä¸€èˆ¬çš„ã«ã¯50pxï¼‰
                    const gridSize = 50; // å¤šãã®GUIã§ã¯50pxã‚°ãƒªãƒƒãƒ‰
                    const columnIndex = Math.round(leftPosition / gridSize);
                    
                    console.log(`ğŸ” Gate processing: ${gateType} at position ${leftPosition}px â†’ column ${columnIndex} (qubit ${qubitIndex})`);
                    
                    allGates.push({
                        type: gateType,
                        position: leftPosition,
                        qubitIndex: qubitIndex,
                        timestamp: timestamp,
                        targetQubit: null, // å°†æ¥ã®2é‡å­ãƒ“ãƒƒãƒˆã‚²ãƒ¼ãƒˆå¯¾å¿œç”¨
                        angle: null, // å°†æ¥ã®å›è»¢ã‚²ãƒ¼ãƒˆå¯¾å¿œç”¨
                        columnIndex: columnIndex, // Xåº§æ¨™ã‚’ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¤‰æ›
                        rowIndex: qubitIndex // Yåº§æ¨™ï¼ˆé‡å­ãƒ“ãƒƒãƒˆè¡Œï¼‰
                    });
                });
            });
            
            // **ç‰©ç†é †ã‚½ãƒ¼ãƒˆï¼šå·¦ã‹ã‚‰å³ï¼ˆã‚«ãƒ©ãƒ ï¼‰â†’ä¸Šã‹ã‚‰ä¸‹ï¼ˆè¡Œï¼‰**
            allGates.sort((a, b) => {
                // ã‚«ãƒ©ãƒ é †ãŒæœ€å„ªå…ˆï¼ˆå·¦ã‹ã‚‰å³ï¼‰
                if (a.columnIndex !== b.columnIndex) {
                    return a.columnIndex - b.columnIndex;
                }
                // åŒã˜ã‚«ãƒ©ãƒ ãªã‚‰è¡Œé †ï¼ˆä¸Šã‹ã‚‰ä¸‹ï¼‰
                if (a.rowIndex !== b.rowIndex) {
                    return a.rowIndex - b.rowIndex;
                }
                // æœ€å¾Œã«ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆé…ç½®é †åºã® fallbackï¼‰
                return a.timestamp - b.timestamp;
            });
            
            console.log('ğŸ“Š JavaScript sorted gate order:');
            allGates.forEach((gate, index) => {
                console.log(`  ${index + 1}: ${gate.type} | Col: ${gate.columnIndex} | Row: ${gate.rowIndex} | Pos: ${gate.position}px | Qubit: ${gate.qubitIndex}`);
            });
            
            // é‡å­ãƒ“ãƒƒãƒˆåˆ¥ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const qubits = [];
            for (let i = 0; i < qubitLines.length; i++) {
                qubits.push({
                    index: i,
                    gates: []
                });
            }
            
            // ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸã‚²ãƒ¼ãƒˆã‚’å„é‡å­ãƒ“ãƒƒãƒˆã«å‰²ã‚Šå½“ã¦
            allGates.forEach(gate => {
                if (gate.qubitIndex < qubits.length) {
                    qubits[gate.qubitIndex].gates.push({
                        type: gate.type,
                        position: gate.position,
                        targetQubit: gate.targetQubit,
                        angle: gate.angle
                    });
                }
            });
            
            return {
                qubits: qubits,
                globalGateOrder: allGates.map((gate, index) => ({
                    gateIndex: index + 1,
                    qubitIndex: gate.qubitIndex,
                    type: gate.type,
                    timestamp: gate.timestamp,
                    columnIndex: gate.columnIndex,
                    rowIndex: gate.rowIndex
                }))
            };
        }
    };

    // ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã‚²ãƒ¼ãƒˆè¦ç´ ã‹ã‚‰ã‚²ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã‚’å–å¾—
    function getGateTypeFromElement(element) {
        // ãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æœ€åˆã«ç¢ºèªï¼ˆæœ€ã‚‚ç¢ºå®Ÿï¼‰
        const textContent = element.textContent?.trim() || '';
        console.log(`ğŸ” Detecting gate type from element:`, element, `text: "${textContent}"`);
        console.log(`ğŸ“± Element classes:`, Array.from(element.classList));
        console.log(`ğŸ·ï¸ Element innerHTML:`, element.innerHTML);
        
        // **I-gateå°‚ç”¨ã®è©³ç´°æ¤œå‡º**
        if (textContent === 'I' || textContent === 'ğˆ' || textContent === 'Identity') {
            console.log('âœ… Detected I gate from text content');
            return 'I';
        }
        
        // **åŸºæœ¬ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ã®åˆ¤å®š**
        if (textContent === 'H') return 'H';
        if (textContent === 'Tâ€ ') return 'Tâ€ ';
        if (textContent === 'Sâ€ ') return 'Sâ€ ';
        if (textContent === 'Vâ€ ') return 'Vâ€ ';
        if (textContent === 'T') return 'T';
        if (textContent === 'S') return 'S';
        if (textContent === 'V') return 'V';
        if (textContent === 'Y') return 'Y';
        if (textContent === 'Z') return 'Z';
        if (textContent === 'P') return 'P';
        if (textContent === 'Rx') return 'Rx';
        if (textContent === 'Ry') return 'Ry';
        if (textContent === 'Rz') return 'Rz';
        if (textContent === '|0âŸ©') return '|0âŸ©';
        
        // **HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¨ã‚¯ãƒ©ã‚¹ã«ã‚ˆã‚‹åˆ¤å®šï¼ˆãƒ†ã‚­ã‚¹ãƒˆãŒç„¡ã„å ´åˆï¼‰**
        const content = element.innerHTML || '';
        
        // I-gateå°‚ç”¨ã®ã‚¯ãƒ©ã‚¹åˆ¤å®š
        if (element.classList.contains('i-gate') || 
            element.classList.contains('identity-gate') || 
            element.classList.contains('identity')) {
            console.log('âœ… Detected I gate from class');
            return 'I';
        }
        
        // HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã‚‰I-gateã‚’æ¤œå‡º
        if (content.includes('I') && !content.includes('H') && !content.includes('circle')) {
            console.log('âœ… Detected I gate from innerHTML content');
            return 'I';
        }
        
        // ãã®ä»–ã®ã‚¯ãƒ©ã‚¹åã«ã‚ˆã‚‹åˆ¤å®š
        if (element.classList.contains('h-gate')) {
            console.log('âœ… Detected H gate from class');
            return 'H';
        }
        
        // SVGãƒ™ãƒ¼ã‚¹ã®Xã‚²ãƒ¼ãƒˆã‚’åˆ¤å®š
        if (content.includes('<svg') || content.includes('viewBox') || 
            content.includes('circle') || content.includes('<line')) {
            console.log('âœ… Detected X gate from SVG content');
            return 'X';
        }
        
        console.log('âš ï¸ Unknown gate type, defaulting to H');
        return 'H'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    }
})();

// ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦éœ²å‡ºï¼ˆC#ã‹ã‚‰å‘¼ã³å‡ºã—å¯èƒ½ï¼‰
window.getCircuitData = function() {
    return JSON.stringify(window.dragAndDropInterop.getCircuitData());
};
</script>
