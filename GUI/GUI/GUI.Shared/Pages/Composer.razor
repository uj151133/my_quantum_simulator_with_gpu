@page "/composer"
@inject IJSRuntime JSRuntime

<style>
.button {
    color: white;
    background-color: #512BD4;
    font-family: OpenSansRegular, sans-serif;
    font-size: 14px;
    padding: 10px 14px;
    min-height: 44px;
    min-width: 44px;
    border-width: 0px;
    border-radius: 8px;
}

.button:disabled {
    color: #141414;
    background-color: #C8C8C8;
}

.h-gate {
    position: relative;
    text-align: center;
    width: 40px;
    height: 40px;
    line-height: 40px;
    border: none;
    border-radius: 0px;
    background-color: #fa4d56;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.h-gate p {
    margin: 0;
    padding: 0;
}

.classical-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #4588ff;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.classical-gate p {
    margin: 0;
    padding: 0;
}

.phase-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #bae6fe;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.phase-gate p {
    margin: 0;
    padding: 0;
}

.other-gate {
    position: relative;
    text-align: center;
    width: 39px;
    height: 39px;
    line-height: 39px;
    border: none;
    border-radius: 0px;
    background-color: #a1a9af;
    color: black;
    font-family: OpenSansRegular, sans-serif;
    font-size: 20px;
    font-weight: medium;
    cursor: pointer;
    user-select: none;
}

.other-gate p {
    margin: 0;
    padding: 0;
}

.trash-zone {
    position: static;
    transform: none;
    z-index: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: linear-gradient(145deg, #ff6b6b, #ee5a52);
    box-shadow: 
        0 8px 20px rgba(238, 90, 82, 0.3),
        inset 0 -3px 10px rgba(0, 0, 0, 0.1),
        inset 0 3px 10px rgba(255, 255, 255, 0.2);
    cursor: default;
    user-select: none;
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    overflow: hidden;
}

.trash-zone:hover {
    transform: scale(1.05);
    box-shadow: 
        0 12px 25px rgba(238, 90, 82, 0.4),
        inset 0 -3px 10px rgba(0, 0, 0, 0.1),
        inset 0 3px 10px rgba(255, 255, 255, 0.3);
}

.trash-zone.drag-over {
    transform: translateY(-50%) scale(1.1);
    background: linear-gradient(145deg, #27ae60, #229954);
    box-shadow: 
        0 20px 40px rgba(39, 174, 96, 0.5),
        inset 0 -3px 10px rgba(0, 0, 0, 0.2),
        inset 0 3px 10px rgba(255, 255, 255, 0.4);
    animation: pulse 0.6s infinite alternate;
}

@@keyframes pulse {
    0% { box-shadow: 0 20px 40px rgba(39, 174, 96, 0.5), inset 0 -3px 10px rgba(0, 0, 0, 0.2), inset 0 3px 10px rgba(255, 255, 255, 0.4); }
    100% { box-shadow: 0 25px 50px rgba(39, 174, 96, 0.7), inset 0 -5px 15px rgba(0, 0, 0, 0.3), inset 0 5px 15px rgba(255, 255, 255, 0.5); }
}

.trash-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 2;
}

.trash-icon {
    color: white;
    margin-bottom: 8px;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    transition: transform 0.2s ease;
}

.trash-zone:hover .trash-icon {
    transform: scale(1.1) rotateZ(5deg);
}

.trash-zone.drag-over .trash-icon {
    transform: scale(1.2) rotateZ(-5deg);
    animation: shake 0.3s ease-in-out infinite;
}

@@keyframes shake {
    0%, 100% { transform: scale(1.2) rotateZ(-5deg) translateX(0); }
    25% { transform: scale(1.2) rotateZ(-5deg) translateX(-2px); }
    75% { transform: scale(1.2) rotateZ(-5deg) translateX(2px); }
}

.trash-text {
    margin: 0;
    padding: 0;
    font-size: 9px;
    font-weight: 600;
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    text-align: center;
    line-height: 1.2;
    transition: all 0.2s ease;
}

.trash-zone:hover .trash-text {
    transform: scale(1.05);
}

.trash-glow {
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255, 107, 107, 0.3) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
}

.trash-zone:hover .trash-glow {
    opacity: 1;
}

.trash-zone.drag-over .trash-glow {
    background: radial-gradient(circle, rgba(39, 174, 96, 0.4) 0%, transparent 70%);
    opacity: 1;
}

.x-gate {
    width: 40px;
    height: 40px;
}

.x-gate:hover {
    filter: brightness(0.9);
}

.qubit-line {
    position: relative;
    flex-grow: 1;
    height: 1px;
    min-height: 30px;
    background-color: transparent;
    border: none;
    margin: 0;
    padding: 15px 0;
    background-image: 
        linear-gradient(to right, rgba(128, 128, 128, 0.2) 1px, transparent 1px);
    background-size: 50px 1px;
    background-position: 0 50%;
    transition: all 0.2s ease;
    cursor: crosshair;
    pointer-events: auto;
}

.qubit-line::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    background-color: currentColor;
    transform: translateY(-50%);
    z-index: 1;
}

.stepper {
    display: flex;
    align-items: center;
    gap: 8px;
}

.stepper-button {
    min-width: 44px;
    min-height: 44px;
    padding: 0;
    font-size: 20px;
    font-weight: bold;
}

.stepper-input {
    width: 80px;
    height: 44px;
    text-align: center;
    font-size: 16px;
    border: 1px solid #512BD4;
    border-radius: 8px;
    padding: 0 8px;
}

.stepper-input:focus {
    outline: none;
    box-shadow: 0 0 0 0.1rem white, 0 0 0 0.25rem #258cfb;
}

.gate-section {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 3px;
    margin-bottom: 5px;
}

.gate-section label {
    color: #333;
    font-weight: 600;
    margin-bottom: 2px;
    font-size: 13px;
}

.gate-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
}

.horizontal-container {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-right: 160px;
}

.vertical-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
}

.dragging {
    opacity: 0.5;
    transform: scale(0.9);
    transition: all 0.2s ease;
}

.dropped-gate {
    min-width: 30px !important;
    min-height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-size: 14px !important;
    border-radius: 0px !important;
    user-select: none !important;
    text-align: center !important;
    line-height: normal !important;
    font-family: OpenSansRegular, sans-serif !important;
    font-weight: medium !important;
    border: none !important;
    cursor: grab !important;
    position: absolute !important;
    transform: translateY(-50%) !important;
    z-index: 10 !important;
    pointer-events: auto !important;
    transition: all 0.2s ease !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

.dropped-gate.h-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #fa4d56 !important;
    color: black !important;
    font-size: 20px !important;
    line-height: 40px !important;
}

.dropped-gate.classical-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #4588ff !important;
    color: black !important;
    font-size: 18px !important;
    line-height: 40px !important;
}

.dropped-gate.phase-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #bae6fe !important;
    color: black !important;
    font-size: 18px !important;
    line-height: 40px !important;
}

.dropped-gate.other-gate {
    width: 40px !important;
    height: 40px !important;
    background-color: #a1a9af !important;
    color: black !important;
    font-size: 16px !important;
    line-height: 40px !important;
}

.dropped-gate:hover {
    opacity: 0.8 !important;
    cursor: grab !important;
    filter: brightness(1.1) !important;
    transform: translateY(-50%) scale(1.05) !important;
}

.dropped-gate.dragging {
    opacity: 0.5 !important;
    cursor: grabbing !important;
    transform: translateY(-50%) scale(0.9) !important;
    transition: all 0.2s ease !important;
    z-index: 1000 !important;
}

.qubit-line:hover {
    height: 3px !important;
    background-color: #512BD4 !important;
    transition: all 0.2s ease;
}

.gate-palette {
    background-color: #f5f5f5;
    padding: 8px;
    border-radius: 6px;
    border: 2px dashed #ccc;
    min-width: 400px;
}

.gate-palette h3 {
    margin-top: 0;
    margin-bottom: 5px;
    color: #333;
    font-size: 18px;
}

.usage-hint {
    font-size: 12px;
    color: #666;
    margin: -3px 0 5px 0;
    padding: 8px;
    background-color: rgba(81, 43, 212, 0.1);
    border-radius: 4px;
    border-left: 3px solid #512BD4;
}

@@media (prefers-color-scheme: dark) {
    .button {
        color: #242424;
        background-color: #ac99ea;
    }

    .button:disabled {
        color: #c8c8c8;
        background-color: #404040;
    }

    .stepper-input {
        background-color: #242424;
        color: #fff;
        border-color: #ac99ea;
    }

    .gate-palette {
        background-color: #2d2d2d;
        border-color: #555;
    }

    .gate-palette h3 {
        color: #fff;
    }

    .usage-hint {
        color: #ccc;
        background-color: rgba(172, 153, 234, 0.1);
        border-left-color: #ac99ea;
    }

    .gate-palette label {
        color: #ccc;
    }

    .gate-section label {
        color: #ccc;
        font-size: 13px;
    }

    .qubit-line:hover {
        background-color: #ac99ea !important;
    }
}

.dropped-gate p {
    margin: 0 !important;
    padding: 0 !important;
    color: inherit !important;
    font-size: inherit !important;
    line-height: inherit !important;
}

.dropped-gate svg {
    width: 25px !important;
    height: 25px !important;
    display: inline-block !important;
    vertical-align: middle !important;
}

.dropped-gate sup {
    font-size: 0.7em !important;
    vertical-align: super !important;
    line-height: 0 !important;
}

.dropped-gate sub {
    font-size: 0.7em !important;
    vertical-align: sub !important;
    line-height: 0 !important;
}

.header-container {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 20px;
    gap: 30px;
}

.title-section {
    flex: 1;
}

.controls-section {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 15px;
    margin-top: 10px;
}
</style>

<div class="header-container">
    <div class="title-section">
        <h1>Composer</h1>
        <div class="controls-section">
            <div class="stepper-section">
                <p role="status">number of qubits: @currentCount</p>
                <div class="stepper">
                    <button class="button stepper-button" @onclick="DecrementCount">-</button>
                    <input type="number" 
                        class="stepper-input" 
                        value="@currentCount"
                        @onchange="OnInputChange" />
                    <button class="button stepper-button" @onclick="IncrementCount">+</button>
                </div>
            </div>
            
            <!-- ゴミ箱エリア -->
            <div class="trash-zone" title="ここにゲートをドラッグして削除">
                <div class="trash-container">
                    <svg class="trash-icon" viewBox="0 0 24 24" width="24" height="24">
                        <path d="M19 7H16V6C16 4.89 15.11 4 14 4H10C8.89 4 8 4.89 8 6V7H5C4.45 7 4 7.45 4 8S4.45 9 5 9H6V19C6 20.11 6.89 21 8 21H16C17.11 21 18 20.11 18 19V9H19C19.55 9 20 8.55 20 8S19.55 7 19 7ZM10 6H14V7H10V6ZM16 19H8V9H16V19Z" fill="currentColor"/>
                        <path d="M10 11V17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        <path d="M14 11V17" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                    <p class="trash-text">ゲートを削除</p>
                    <div class="trash-glow"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="vertical-container gate-palette">
        <h3>量子ゲートパレット</h3>
        <p class="usage-hint">💡 ゲートをドラッグして量子ビット線上に配置できます。ダブルクリックで削除、ゴミ箱にドラッグしても削除できます。</p>        <div class="gate-section">
            <label>基本ゲート:</label>
            <div class="gate-row">
                <div class="h-gate" draggable="true" title="Hadamardゲート">H</div>
            </div>
        </div>

        <div class="gate-section">
            <label>クラシカルゲート:</label>
            <div class="gate-row">
                <div class="classical-gate" draggable="true" title="Xゲート（Pauliゲート）">
                    <svg class="x-gate" viewBox="0 0 25 25" width="25" height="25">
                        <circle cx="12.5" cy="12.5" r="6.25" stroke="black" stroke-width="1" fill="none"/>
                        <line x1="6.25" y1="12.5" x2="18.75" y2="12.5" stroke="black" stroke-width="1"/>
                        <line x1="12.5" y1="6.25" x2="12.5" y2="18.75" stroke="black" stroke-width="1"/>
                    </svg>
                </div>
                <div class="classical-gate" draggable="true" title="Identityゲート">
                    <p>I</p>
                </div>
            </div>
        </div>

        <div class="gate-section">
            <label>位相ゲート:</label>
            <div class="gate-row">
                <div class="phase-gate" draggable="true" title="Tゲート">
                    <p>T</p>
                </div>
                <div class="phase-gate" draggable="true" title="T†ゲート">
                    <p>T<sup>†</sup></p>
                </div>
                <div class="phase-gate" draggable="true" title="Sゲート">
                    <p>S</p>
                </div>
                <div class="phase-gate" draggable="true" title="S†ゲート">
                    <p>S<sup>†</sup></p>
                </div>
                <div class="phase-gate" draggable="true" title="Zゲート">
                    <p>Z</p>
                </div>
                <div class="phase-gate" draggable="true" title="位相ゲート">
                    <p>P</p>
                </div>
                <div class="phase-gate" draggable="true" title="回転Zゲート">
                    <p>RZ</p>
                </div>
            </div>
        </div>

        <div class="gate-section">
            <label>その他:</label>
            <div class="gate-row">
                <div class="other-gate" draggable="true" title="初期状態">
                    <p>|0⟩</p>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private int currentCount = 2;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {
            if (firstRender)
            {
                // 少し待ってからJavaScriptを呼び出す
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.initializeDragAndDrop");
            }
            else
            {
                // 量子ビット数が変更された時にドロップゾーンを再初期化
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
        }
        catch (Exception ex)
        {
            // JavaScript関数がまだ読み込まれていない場合は無視
            Console.WriteLine($"JavaScript function not yet available: {ex.Message}");
        }
    }

    private async Task IncrementCount()
    {
        currentCount++;
        StateHasChanged();
        try
        {
            await Task.Delay(10); // DOM更新を待つ
            await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"JavaScript function not available: {ex.Message}");
        }
    }

    private async Task DecrementCount()
    {
        if (currentCount > 0)
        {
            currentCount--;
            StateHasChanged();
            try
            {
                await Task.Delay(10); // DOM更新を待つ
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript function not available: {ex.Message}");
            }
        }
    }

    private async Task OnInputChange(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int value) && value >= 0)
        {
            currentCount = value;
            StateHasChanged();
            try
            {
                await Task.Delay(10); // DOM更新を待つ
                await JSRuntime.InvokeVoidAsync("dragAndDropInterop.reinitialize");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript function not available: {ex.Message}");
            }
        }
    }
}

<!-- 量子回路エリア -->
<div class="circuit-area">
@for (int i = 0; i < currentCount; i++)
{
    <div style="display: flex; align-items: center; margin: 15px 0;">
        <span style="margin-right: 20px; font-size: 20px;">q<sub>@i</sub></span>
        <div class="qubit-line"></div>
    </div>
}
</div>

<script>
// ドラッグ&ドロップ機能の初期化
window.dragAndDropInterop = (function() {
    
    // プライベート変数
    let draggedElement = null;
    let isFromDroppedGate = false;

    // ゲートのHTMLコンテンツを取得
    function getGateContent(element) {
        // SVGが含まれているかチェック
        if (element.querySelector('svg')) {
            // SVGを含む場合は全体のHTMLを保持
            return {
                type: 'html',
                content: element.innerHTML
            };
        } else if (element.querySelector('p')) {
            // pタグが含まれている場合はそのHTMLを保持
            return {
                type: 'html',
                content: element.innerHTML
            };
        } else {
            // プレーンテキストの場合
            return {
                type: 'text',
                content: element.textContent || 'H'
            };
        }
    }

    // ゲートタイプを取得
    function getGateType(element) {
        const classes = element.className.split(' ');
        return classes.find(cls => cls.endsWith('-gate')) || 'h-gate';
    }

    // ドラッグ開始
    function handleDragStart(e) {
        draggedElement = e.target;
        isFromDroppedGate = e.target.classList.contains('dropped-gate');
        
        e.target.classList.add('dragging');
        
        // ゲートの情報を保存
        const gateContent = getGateContent(e.target);
        const gateType = getGateType(e.target);
        
        const dragData = {
            gateType: gateType,
            isFromDropped: isFromDroppedGate,
            sourceId: isFromDroppedGate ? e.target.id || Date.now().toString() : null,
            contentType: gateContent.type,
            content: gateContent.content
        };
        
        e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
        e.dataTransfer.effectAllowed = isFromDroppedGate ? 'move' : 'copy';
    }

    // ドラッグ終了
    function handleDragEnd(e) {
        e.target.classList.remove('dragging');
        draggedElement = null;
        isFromDroppedGate = false;
    }

    // ドロップゾーンの初期化
    function initializeDropZones() {
        // 量子ビット線のドロップゾーン
        const qubitLines = document.querySelectorAll('.qubit-line');
        
        qubitLines.forEach((line, index) => {
            // 既存のイベントリスナーを削除
            line.removeEventListener('dragover', handleQubitDragOver);
            line.removeEventListener('drop', handleQubitDrop);
            line.removeEventListener('dragenter', handleQubitDragEnter);
            line.removeEventListener('dragleave', handleQubitDragLeave);
            
            // 新しいイベントリスナーを追加
            line.addEventListener('dragover', handleQubitDragOver);
            line.addEventListener('drop', handleQubitDrop);
            line.addEventListener('dragenter', handleQubitDragEnter);
            line.addEventListener('dragleave', handleQubitDragLeave);
            
            // ドロップゾーンが正しく設定されているかテスト
            line.style.minHeight = '20px';
            line.style.position = 'relative';
        });

        // ゴミ箱のドロップゾーン
        const trashZone = document.querySelector('.trash-zone');
        if (trashZone) {
            trashZone.removeEventListener('dragover', handleTrashDragOver);
            trashZone.removeEventListener('drop', handleTrashDrop);
            trashZone.removeEventListener('dragenter', handleTrashDragEnter);
            trashZone.removeEventListener('dragleave', handleTrashDragLeave);
            
            trashZone.addEventListener('dragover', handleTrashDragOver);
            trashZone.addEventListener('drop', handleTrashDrop);
            trashZone.addEventListener('dragenter', handleTrashDragEnter);
            trashZone.addEventListener('dragleave', handleTrashDragLeave);
        }
    }

    // 量子ビット線のドラッグイベント
    function handleQubitDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = isFromDroppedGate ? 'move' : 'copy';
    }

    function handleQubitDragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        const target = e.target.closest('.qubit-line') || e.target;
        target.style.backgroundColor = '#512BD4';
        target.style.height = '3px';
    }

    function handleQubitDragLeave(e) {
        e.stopPropagation();
        const target = e.target.closest('.qubit-line') || e.target;
        // 子要素からのleaveイベントを無視
        if (!target.contains(e.relatedTarget)) {
            target.style.backgroundColor = '';
            target.style.height = '1px';
        }
    }

    function handleQubitDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const target = e.target.closest('.qubit-line') || e.target;
        target.style.backgroundColor = '';
        target.style.height = '1px';
        
        try {
            const dragDataString = e.dataTransfer.getData('text/plain');
            
            if (!dragDataString) {
                return;
            }
            
            const data = JSON.parse(dragDataString);
            
            const qubitLine = target;
            
            // 移動の場合は元の要素を削除
            if (data.isFromDropped && draggedElement) {
                draggedElement.remove();
            }
            
            // 新しいゲート要素を作成
            const newGate = document.createElement('div');
            newGate.className = data.gateType + ' dropped-gate';
            newGate.draggable = true;
            newGate.id = 'gate-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            
            // コンテンツを設定
            if (data.contentType === 'html') {
                newGate.innerHTML = data.content;
            } else {
                newGate.textContent = data.content;
            }
            
            // ドロップ位置を計算（グリッドの縦線にスナップ）
            const rect = qubitLine.getBoundingClientRect();
            const dropX = e.clientX - rect.left;
            const gridSize = 50; // CSSのbackground-sizeと同じ
            const gateWidth = 40; // ゲートの幅
            const gateHalfWidth = gateWidth / 2; // 20px
            
            // 最も近い縦線の位置にスナップ（0px、50px、100px、150px...）
            const snappedX = Math.round(dropX / gridSize) * gridSize;
            
            // ゲートの中央が縦線に来るように調整（左端位置 = 縦線位置 - ゲート幅の半分）
            const adjustedX = snappedX - gateHalfWidth;
            
            // グリッド範囲内に制限
            const maxX = qubitLine.offsetWidth - gateWidth; // ゲートの幅を考慮
            let finalX = Math.max(0 - gateHalfWidth, Math.min(adjustedX, maxX));
            
            // 重複チェック - 同じ位置に既存のゲートがあるかチェック
            const existingGates = qubitLine.querySelectorAll('.dropped-gate');
            let positionOccupied = true;
            let attempts = 0;
            
            while (positionOccupied && attempts < 20) { // 最大20回試行
                positionOccupied = false;
                for (const existingGate of existingGates) {
                    const existingX = parseInt(existingGate.style.left) || 0;
                    if (Math.abs(finalX - existingX) < 45) { // 45px以内は重複とみなす
                        positionOccupied = true;
                        finalX += gridSize; // 次のグリッド位置に移動
                        if (finalX > maxX) {
                            finalX = 0 - gateHalfWidth; // 右端を超えたら最初のグリッド位置に戻る（左端の縦線）
                        }
                        break;
                    }
                }
                attempts++;
            }
            
            // 基本スタイルを設定
            newGate.style.position = 'absolute';
            newGate.style.left = finalX + 'px';
            newGate.style.transform = 'translateY(-50%)';
            newGate.style.cursor = 'grab';
            newGate.style.zIndex = '10';
            newGate.style.display = 'flex';
            newGate.style.alignItems = 'center';
            newGate.style.justifyContent = 'center';
            newGate.style.textAlign = 'center';
            newGate.style.fontFamily = 'OpenSansRegular, sans-serif';
            newGate.style.fontWeight = 'medium';
            newGate.style.userSelect = 'none';
            newGate.style.border = 'none';
            newGate.style.borderRadius = '0px';
            newGate.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
            newGate.style.transition = 'all 0.2s ease';
            
            // ゲートタイプ別のスタイルを適用
            if (data.gateType === 'h-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#fa4d56';
                newGate.style.color = 'black';
                newGate.style.fontSize = '20px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'classical-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#4588ff';
                newGate.style.color = 'black';
                newGate.style.fontSize = '18px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'phase-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#bae6fe';
                newGate.style.color = 'black';
                newGate.style.fontSize = '18px';
                newGate.style.lineHeight = '40px';
            } else if (data.gateType === 'other-gate') {
                newGate.style.width = '40px';
                newGate.style.height = '40px';
                newGate.style.backgroundColor = '#a1a9af';
                newGate.style.color = 'black';
                newGate.style.fontSize = '16px';
                newGate.style.lineHeight = '40px';
            }
            
            // イベントリスナーを追加
            newGate.addEventListener('dragstart', handleDragStart);
            newGate.addEventListener('dragend', handleDragEnd);
            
            // ダブルクリックで削除
            newGate.addEventListener('dblclick', function() {
                newGate.remove();
            });
            
            // 内部要素のスタイルを調整
            const pElements = newGate.querySelectorAll('p');
            pElements.forEach(p => {
                p.style.margin = '0';
                p.style.padding = '0';
                p.style.color = 'inherit';
                p.style.fontSize = 'inherit';
                p.style.lineHeight = 'inherit';
            });
            
            const svgElements = newGate.querySelectorAll('svg');
            svgElements.forEach(svg => {
                svg.style.width = '25px';
                svg.style.height = '25px';
                svg.style.display = 'inline-block';
                svg.style.verticalAlign = 'middle';
            });
            
            // 量子ビット線に配置
            qubitLine.style.position = 'relative';
            qubitLine.appendChild(newGate);
            
        } catch (error) {
            // エラーハンドリング
        }
    }

    // ゴミ箱のドラッグイベント
    function handleTrashDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    }

    function handleTrashDragEnter(e) {
        e.preventDefault();
        e.target.closest('.trash-zone').classList.add('drag-over');
    }

    function handleTrashDragLeave(e) {
        const trashZone = e.target.closest('.trash-zone');
        if (trashZone && !trashZone.contains(e.relatedTarget)) {
            trashZone.classList.remove('drag-over');
        }
    }

    function handleTrashDrop(e) {
        e.preventDefault();
        e.target.closest('.trash-zone').classList.remove('drag-over');
        
        try {
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            
            // ドロップされたゲートのみ削除可能
            if (data.isFromDropped && draggedElement) {
                draggedElement.remove();
            }
            
        } catch (error) {
            // エラーハンドリング
        }
    }

    // パレットのゲートを初期化
    function initializePaletteGates() {
        const gates = document.querySelectorAll('.h-gate, .classical-gate, .phase-gate, .other-gate');
        
        gates.forEach((gate, index) => {
            // 既存のイベントリスナーを削除
            gate.removeEventListener('dragstart', handleDragStart);
            gate.removeEventListener('dragend', handleDragEnd);
            
            // 新しいイベントリスナーを追加
            gate.addEventListener('dragstart', handleDragStart);
            gate.addEventListener('dragend', handleDragEnd);
            
            // draggableが正しく設定されているか確認
            if (!gate.draggable) {
                gate.draggable = true;
            }
        });
    }

    // パブリックAPI
    return {
        initializeDragAndDrop: function() {
            initializePaletteGates();
            initializeDropZones();
        },

        reinitialize: function() {
            this.initializeDragAndDrop();
        }
    };
})();
</script>
