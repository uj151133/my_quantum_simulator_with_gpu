@page "/heartbeat"
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@implements IDisposable
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components
@using System.Text.Json

<PageTitle>Heartbeat</PageTitle>

<!-- 完全統合実装：CSS + JavaScript + HTML + Veda.js Background -->
<style>
/* ページ全体の背景を透明にする */
body, html {
    background: transparent !important;
    background-color: transparent !important;
}

/* Blazor Serverの既存背景を無効化（サイドバーは除く） */
.main, .content, .page {
    background: transparent !important;
    background-color: transparent !important;
}

/* サイドバーの背景を保持 */
.sidebar {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%) !important; /* 他のページと同じグラデーション */
    background-color: rgb(5, 39, 103) !important;
}

/* サイドバー内の要素の背景も適切に設定 */
.sidebar .nav-item {
    background: transparent;
}

.sidebar .nav-item.active {
    background: rgba(255, 255, 255, 0.1) !important;
}

.sidebar .nav-link {
    color: white !important;
}

.sidebar .nav-link:hover {
    background: rgba(255, 255, 255, 0.1) !important;
}

/* より具体的なサイドバー背景設定 */
nav.navbar, .navbar-dark, .bg-dark {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%) !important;
    background-color: rgb(5, 39, 103) !important;
}

/* トップ行のナビゲーションバーは除外 */
.sidebar .top-row.navbar,
.top-row.navbar-dark {
    background: rgba(0,0,0,0.4) !important;
    background-color: rgba(0,0,0,0.4) !important;
    background-image: none !important;
}

/* 最優先でトップ行の背景を半透明黒に強制変更 */
.sidebar .top-row.ps-3.navbar.navbar-dark,
div.sidebar div.top-row,
.sidebar > .top-row {
    background: rgba(0,0,0,0.4) !important;
    background-color: rgba(0,0,0,0.4) !important;
    background-image: none !important;
}

/* サイドバーのトップ行は元の半透明背景を維持 - より強力なセレクター */
.sidebar .top-row,
.top-row.ps-3.navbar.navbar-dark,
.navbar-dark.top-row {
    background: rgba(0,0,0,0.4) !important;
    background-color: rgba(0,0,0,0.4) !important;
    background-image: none !important;
}

/* ナビゲーションバーのブランド */
.navbar-brand {
    color: white !important;
}

/* サイドバー全体のスタイル保持 */
.sidebar-content, .nav-scrollable {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%) !important;
    background-color: rgb(5, 39, 103) !important;
}

/* アクティブなナビゲーション項目 */
.nav-item .nav-link.active {
    background: rgba(255, 255, 255, 0.2) !important;
    color: white !important;
}

/* ホバー効果 */
.nav-item .nav-link:hover {
    background: rgba(255, 255, 255, 0.1) !important;
    color: white !important;
}

/* Veda.js 背景エフェクト */
.veda-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    overflow: hidden;
    pointer-events: none;
}

.veda-canvas {
    width: 100vw !important;
    height: 100vh !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    z-index: -1 !important;
    background: transparent;
    object-fit: cover;
    display: block !important;
}

/* ダッシュボード要素を背景エフェクトの上に配置 */
.status-dashboard {
    position: relative;
    z-index: 2;
    background: rgba(255, 255, 255, 0.75); // 背景を透明にして量子回路が見えるように
    backdrop-filter: blur(8px); // ガラスエフェクトを強化
    border-radius: 16px;
    padding: 20px;
    margin: 20px;
}

/* ハートビートアニメーション */
.heart-icon {
    animation: heartbeat 1.2s ease-in-out infinite !important;
    color: #e74c3c !important;
    fill: #e74c3c !important;
    filter: drop-shadow(0 0 5px rgba(231, 76, 60, 0.5));
    transform-origin: center !important;
    display: inline-block !important;
    transition: none !important;
}

.heart-icon:hover {
    animation: heartbeat-fast 0.8s ease-in-out infinite !important;
    filter: drop-shadow(0 0 8px rgba(231, 76, 60, 0.8));
}

.heart-icon path {
    fill: currentColor !important;
}

.card {
    /* From https://css.glass */
    background: rgba(255, 255, 255, 0.2);
    border-radius: 16px;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

@@keyframes heartbeat {
    0% { 
        transform: scale(1); 
    }
    14% { 
        transform: scale(1.3); 
    }
    28% { 
        transform: scale(1); 
    }
    42% { 
        transform: scale(1.3); 
    }
    70% { 
        transform: scale(1); 
    }
    100% { 
        transform: scale(1); 
    }
}

@@keyframes heartbeat-fast {
    0% { 
        transform: scale(1); 
    }
    50% { 
        transform: scale(1.4); 
    }
    100% { 
        transform: scale(1); 
    }
}

/* 既存のスタイル */
h1 {
    display: flex;
    align-items: center;
    gap: 10px;
}

/* レスポンシブデザイン */
@@media (max-width: 768px) {
    /* 削除済み */
}
</style>

<h1>
    <svg class="heart-icon" viewBox="0 0 24 24" width="32" height="32">
        <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="currentColor"/>
    </svg>
    Heartbeat
</h1>

<p>シミュレータプロセスのリアルタイム監視</p>

<!-- Veda.js シェーダー背景エフェクト -->
<!-- キャンバスはJavaScriptで動的に作成してbodyに追加するため、ここには配置しない -->
<!--<div class="veda-background">
    <canvas id="vedaCanvas" class="veda-canvas"></canvas>
</div>-->

<!-- デバッグ表示 (非表示) -->
<div id="debugInfo" style="display: none; position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: white; padding: 8px; border-radius: 8px; font-family: monospace; font-size: 11px; z-index: 1000; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1);">
    <div style="color: #4ade80;">🔧 JS: <span id="jsStatus">Loading...</span></div>
    <div style="color: #60a5fa;">🎨 Canvas: <span id="canvasStatus">Checking...</span></div>
    <div style="color: #a78bfa;">🌌 WebGL: <span id="webglStatus">Testing...</span></div>
    <div style="color: #f472b6;">🧬 Shader: <span id="shaderStatus">Loading...</span></div>
    <div style="color: #fbbf24;">⏱️ Frames: <span id="frameCount">0</span></div>
</div>

@if (currentStatus == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <!-- シミュレーション結果表示 -->
    @if (simulationResult != null)
    {
        <div class="card mb-4">
            <div class="card-header">
                <h4 class="mb-0">🚀 Quantum Circuit Simulation Results</h4>
                <small class="text-muted">@simulationResult.Timestamp</small>
            </div>
            <div class="card-body">
                <div class="row mb-3">
                    <div class="col-md-4">
                        <div class="card">
                            <div class="card-body text-center">
                                <h5 class="card-title text-success">✅ Success</h5>
                                <p class="card-text">Execution Time<br><strong>@(simulationResult.ExecutionTime.ToString("F2"))ms</strong></p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="card">
                            <div class="card-body text-center">
                                <h5 class="card-title text-info">🔢 Gates</h5>
                                <p class="card-text">Total Gates<br><strong>@simulationResult.GateCount</strong></p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="card">
                            <div class="card-body text-center">
                                <h5 class="card-title text-primary">⚡ Status</h5>
                                <p class="card-text">Circuit<br><strong>Completed</strong></p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ゲート実行ログ -->
                <div class="card">
                    <div class="card-header">
                        <h6 class="mb-0">📋 Detailed Gate Execution Log</h6>
                        <small class="text-muted">C++ QMDD Simulator Output Style</small>
                    </div>
                    <div class="card-body">
                        <div style="max-height: 400px; overflow-y: auto; font-family: 'Cascadia Code', 'Fira Code', 'Consolas', monospace; font-size: 11px; line-height: 1.4; background: #1a1a1a; color: #e0e0e0; padding: 15px; border-radius: 8px;">
                            @if (simulationResult.DetailedLog?.Count > 0)
                            {
                                <div style="color: #00FF00; margin-bottom: 10px;">🎯 Found @simulationResult.DetailedLog.Count detailed log entries</div>
                                @foreach (var logEntry in simulationResult.DetailedLog)
                                {
                                    <div class="mb-3" style="border-left: 3px solid #4CAF50; padding-left: 10px; margin-bottom: 15px;">
                                        <!-- Gate Number and Label -->
                                        <div style="color: #81C784; font-weight: bold; margin-bottom: 5px;">
                                            number of gates: @logEntry.GateNumber
                                        </div>
                                        
                                        <!-- Gate Info -->
                                        <div style="color: #FFB74D; margin-bottom: 3px;">
                                            Gate: Gate @logEntry.GateNumber (@logEntry.GateType)
                                        </div>
                                        <div style="color: #E0E0E0; margin-left: 10px; margin-bottom: 3px;">
                                            Qubits: [@string.Join(", ", logEntry.Qubits)]
                                            @if (logEntry.ControlQubits?.Count > 0)
                                            {
                                                <span> (Control: [@string.Join(", ", logEntry.ControlQubits)])</span>
                                            }
                                        </div>
                                        <div style="color: #90CAF9; margin-left: 10px; margin-bottom: 3px;">
                                            Current Gate: Weight = @logEntry.CurrentGate.Weight, Key = @logEntry.CurrentGate.Key
                                        </div>
                                        <div style="color: #CE93D8; margin-left: 10px;">
                                            Current State: Weight = @logEntry.CurrentState.Weight, Key = @logEntry.CurrentState.Key
                                        </div>
                                        <div style="color: #546E7A; margin: 5px 0;">
                                            ================================================================
                                        </div>
                                    </div>
                                }
                                
                                <!-- Final State -->
                                <div style="border-left: 3px solid #FF7043; padding-left: 10px; margin-top: 20px;">
                                    <div style="color: #FF8A65; font-weight: bold; margin-bottom: 5px;">
                                        📊 Final Simulation State
                                    </div>
                                    <div style="color: #FFCC02; margin-left: 10px; font-family: 'Courier New', monospace;">
                                        @if (!string.IsNullOrEmpty(simulationResult.FinalState))
                                        {
                                            <div>@simulationResult.FinalState</div>
                                        }
                                        else
                                        {
                                            <div style="color: #FF6B6B;">Final state information not available</div>
                                        }
                                    </div>
                                    
                                    @* 詳細な最終状態情報がある場合は表示 *@
                                    @if (simulationResult.DetailedLog?.Count > 0)
                                    {
                                        var lastLog = simulationResult.DetailedLog.LastOrDefault();
                                        if (lastLog?.CurrentState != null)
                                        {
                                            <div style="color: #81C784; margin-left: 10px; margin-top: 10px; font-family: 'Courier New', monospace;">
                                                <div style="color: #4CAF50; font-weight: bold;">Final State Details:</div>
                                                <div style="margin-left: 15px;">
                                                    <div>Weight = @(lastLog.CurrentState.Weight ?? "N/A")</div>
                                                    <div>Key = @(lastLog.CurrentState.Key?.ToString() ?? "N/A")</div>
                                                    <div>Is Terminal = @(lastLog.CurrentState.IsTerminal.ToString())</div>
                                                </div>
                                            </div>
                                        }
                                    }
                                </div>
                            }
                            else
                            {
                                <div style="color: #FF6B6B; margin-bottom: 10px;">❌ DetailedLog is empty or null (Count: @(simulationResult.DetailedLog?.Count ?? -1))</div>
                                <!-- Fallback to simple gate list if detailed log is not available -->
                                @if (simulationResult.Gates?.Count > 0)
                                {
                                    <div style="color: #FFA726; margin-bottom: 10px;">📋 Using fallback simple gate display</div>
                                    @foreach (var gate in simulationResult.Gates)
                                    {
                                        <div class="mb-2" style="border-left: 3px solid #4CAF50; padding-left: 10px;">
                                            <div style="color: #81C784; font-weight: bold;">number of gates: @gate.GateNumber</div>
                                            <div style="color: #FFB74D;">Gate: @gate.Label (@gate.Type)</div>
                                            <div style="color: #B39DDB; margin-left: 15px;">
                                                Qubits: [@string.Join(", ", gate.Qubits)]
                                                @if (gate.ControlQubits?.Count > 0)
                                                {
                                                    <span> | Control: [@string.Join(", ", gate.ControlQubits)]</span>
                                                }
                                            </div>
                                            <div style="color: #616161;">============================================================</div>
                                        </div>
                                    }
                                }
                                else
                                {
                                    <div style="color: #FF6B6B;">❌ No Gates data available either</div>
                                }
                            }
                        </div>
                    </div>
                </div>
                
                <div class="text-center mt-3">
                    <button class="btn btn-primary" @onclick="RunNewSimulation">
                        🔄 Run New Simulation
                    </button>
                </div>
            </div>
        </div>
    }
    else
    {
        <!-- 結果がない場合のメッセージ -->
        <div class="card">
            <div class="card-body text-center">
                <h5>📊 Waiting for Simulation Results</h5>
                <p class="text-muted">
                    Run a quantum circuit simulation from the Composer page.<br/>
                    Results will automatically appear here in real-time!
                </p>
                <button class="btn btn-primary" @onclick="GoToComposer">
                    🎛️ Go to Circuit Composer
                </button>
                <div class="mt-3">
                    <small class="text-muted">
                        💡 Heartbeat page automatically updates every 5 seconds to show the latest simulation results
                    </small>
                </div>
            </div>
        </div>
    }
}

@code {
    private HeartbeatInfo? currentStatus;
    private DotNetObjectReference<object>? dotNetRef;
    private SimulationResultData? simulationResult;
    private CancellationTokenSource _cancellationTokenSource = new();
    private CancellationToken _cancellationToken => _cancellationTokenSource.Token;

    protected override async Task OnInitializedAsync()
    {
        // DotNetObjectReferenceを作成
        dotNetRef = DotNetObjectReference.Create<object>(this);
        
        // 初期データを読み込み
        await LoadHeartbeatData();
        
        // リアルタイム更新を開始（5秒間隔）
        _ = Task.Run(async () =>
        {
            while (!_cancellationToken.IsCancellationRequested)
            {
                await Task.Delay(5000, _cancellationToken);
                if (!_cancellationToken.IsCancellationRequested)
                {
                    try
                    {
                        await LoadSimulationResult();
                        await InvokeAsync(StateHasChanged);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error updating simulation results: {ex.Message}");
                    }
                }
            }
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // DOM が完全にレンダリングされるまで少し待機
                await Task.Delay(100);
                
                // シミュレーション結果を読み込み（JavaScript interopは OnAfterRenderAsync で実行）
                await LoadSimulationResult();
                StateHasChanged(); // 再レンダリングをトリガー
                
                // JavaScript初期化（既存のコード）
                var objectExists = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.heartbeatInterop !== 'undefined'");
                
                if (!objectExists)
                {
                    // heartbeatInteropオブジェクトを作成
                    await JSRuntime.InvokeVoidAsync("eval", @"
                        // Heartbeat用のJavaScriptオブジェクトを作成
                        window.heartbeatInterop = {
                            updateInterval: null,
                            vedaInstance: null,
                            
                            startRealTimeUpdate: function(dotNetObjectReference) {
                                console.log('Starting real-time heartbeat updates...');
                                this.updateInterval = setInterval(() => {
                                    try {
                                        dotNetObjectReference.invokeMethodAsync('UpdateHeartbeatData');
                                    } catch (error) {
                                        console.error('Failed to update heartbeat data:', error);
                                    }
                                }, 3000);
                            },
                            
                            stopRealTimeUpdate: function() {
                                if (this.updateInterval) {
                                    clearInterval(this.updateInterval);
                                    this.updateInterval = null;
                                }
                            },
                            
                            animateMetrics: function() {
                                // メトリクス関連のアニメーションは削除済み
                                console.log('Metrics animation skipped (metrics removed)');
                            },
                            
                            initializeVedaBackground: function() {
                                console.log('🎯 initializeVedaBackground called');
                                
                                // キャンバスを取得または作成
                                let canvas = document.getElementById('vedaCanvas');
                                if (!canvas) {
                                    console.log('❌ Veda canvas not found, creating new canvas');
                                    canvas = document.createElement('canvas');
                                    canvas.id = 'vedaCanvas';
                                    canvas.className = 'veda-canvas';
                                    document.body.appendChild(canvas);
                                    console.log('✅ New canvas created and added to body');
                                } else {
                                    console.log('✅ Canvas element found:', canvas);
                                }
                                
                                console.log('📊 Canvas dimensions:', canvas.width, 'x', canvas.height);
                                console.log('🎨 Canvas style:', window.getComputedStyle(canvas));
                                
                                // 直接カスタムWebGLレンダラーを使用
                                this.setupVedaShader(canvas);
                            },
                            
                            loadVedaJS: function() {
                                return new Promise((resolve, reject) => {
                                    if (window.VEDA) {
                                        resolve(window.VEDA);
                                        return;
                                    }
                                    
                                    const script = document.createElement('script');
                                    script.src = 'https://unpkg.com/vedajs@1.3.3/lib/veda.js';
                                    script.onload = () => {
                                        console.log('Veda.js loaded successfully');
                                        resolve(window.VEDA);
                                    };
                                    script.onerror = (error) => {
                                        console.error('Failed to load Veda.js:', error);
                                        reject(error);
                                    };
                                    document.head.appendChild(script);
                                });
                            },
                            
                            setupVedaShader: function(canvas) {
                                console.log('🔧 setupVedaShader called with canvas:', canvas);
                                
                                // デバッグ表示を更新する関数をローカルで定義
                                const updateDebugStatus = (id, status) => {
                                    const element = document.getElementById(id);
                                    if (element) element.textContent = status;
                                };
                                
                                try {
                                    // まず基本的なWebGLコンテキストをテスト
                                    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                                    if (!gl) {
                                        console.warn('⚠️ WebGL not supported, falling back to simple background');
                                        updateDebugStatus('webglStatus', 'Not supported ❌');
                                        this.createSimpleBackground(canvas);
                                        return;
                                    }
                                    
                                    console.log('✅ WebGL context obtained:', gl);
                                    console.log('🔍 WebGL version:', gl.getParameter(gl.VERSION));
                                    console.log('🔍 WebGL renderer:', gl.getParameter(gl.RENDERER));
                                    updateDebugStatus('webglStatus', 'Supported ✅');
                                    
                                    // 外部ファイル（vein.frag）を最優先で読み込み
                                    console.log('🎨 Loading vein.frag shader from external file...');
                                    console.log('📂 Primary source: /shaders/vein.frag');
                                    updateDebugStatus('shaderStatus', 'Loading external...');
                                    
                                    this.loadQuantumShader()
                                        .then(shaderSource => {
                                            console.log('🎉 🎨 External vein.frag loaded and validated successfully!');
                                            console.log('📊 Using external shader with', shaderSource.length, 'characters');
                                            console.log('✨ This is the REAL vein.frag content - not embedded!');
                                            updateDebugStatus('shaderStatus', 'External loaded ✅');
                                            
                                            // シェーダーコンパイル前の最終確認
                                            console.log('🔥 About to compile external vein.frag shader...');
                                            this.setupCustomWebGLRenderer(canvas, shaderSource);
                                        })
                                        .catch(error => {
                                            console.log('⚠️ 🔴 External vein.frag loading failed, using emergency fallback');
                                            console.log('🔍 Failure reason:', error.message);
                                            console.log('📋 Full error details:', error);
                                            updateDebugStatus('shaderStatus', 'Fallback to simple ⚠️');
                                            
                                            console.log('🔄 Loading simple emergency fallback shader...');
                                            const embeddedShader = this.getEmbeddedQuantumShader();
                                            console.log('📊 Using emergency fallback with', embeddedShader.length, 'characters');
                                            console.log('⚠️ This is NOT the full vein.frag - just a simple backup!');
                                            console.log('🔥 About to compile emergency fallback shader...');
                                            this.setupCustomWebGLRenderer(canvas, embeddedShader);
                                        });
                                        
                                        
                                } catch (error) {
                                    console.error('💥 Shader setup failed:', error);
                                    updateDebugStatus('webglStatus', 'Error ❌');
                                    this.createSimpleBackground(canvas);
                                }
                            },
                            
                            loadQuantumShader: async function() {
                                console.log('📂 Fetching quantum shader from /shaders/vein.frag');
                                console.log('🌐 Current URL:', window.location.href);
                                console.log('🔗 Shader URL:', window.location.origin + '/shaders/vein.frag');
                                
                                try {
                                    const response = await fetch('/shaders/vein.frag');
                                    console.log('📡 Fetch response received:', response);
                                    console.log('📊 Response status:', response.status, response.statusText);
                                    console.log('📋 Response headers:', [...response.headers.entries()]);
                                    console.log('🔍 Response type:', response.type);
                                    console.log('✅ Response ok:', response.ok);
                                    
                                    if (!response.ok) {
                                        throw new Error(`Shader fetch failed: ${response.status} ${response.statusText}`);
                                    }
                                    
                                    const shaderSource = await response.text();
                                    console.log('🎉 ✅ vein.frag loaded successfully!');
                                    console.log('📊 Shader length:', shaderSource.length, 'characters');
                                    console.log('🔍 First 200 chars:', shaderSource.substring(0, 200));
                                    console.log('🔍 Last 100 chars:', shaderSource.slice(-100));
                                    
                                    // シェーダーの主要な特徴を検証
                                    const hasUniforms = shaderSource.includes('uniform float time') && 
                                                       shaderSource.includes('uniform vec2 resolution') && 
                                                       shaderSource.includes('uniform float volume');
                                    const hasMain = shaderSource.includes('void main()');
                                    const hasRayMarching = shaderSource.includes('rayMarch');
                                    const hasGetDist = shaderSource.includes('getDist');
                                    
                                    console.log('🔬 Shader validation:');
                                    console.log('  - Has required uniforms:', hasUniforms);
                                    console.log('  - Has main function:', hasMain);
                                    console.log('  - Has ray marching:', hasRayMarching);
                                    console.log('  - Has distance function:', hasGetDist);
                                    
                                    if (!hasUniforms || !hasMain) {
                                        console.warn('⚠️ Shader may be incomplete or corrupted');
                                    } else {
                                        console.log('✅ Shader validation passed - looks good!');
                                    }
                                    
                                    // シェーダーソースをそのまま使用（Veda.js標準uniform名に対応）
                                    const adjustedShaderSource = shaderSource;
                                    
                                    console.log('🔧 Using standard Veda.js uniform names (time, resolution, volume)');
                                    console.log('🎯 Final shader ready for compilation');
                                    return adjustedShaderSource;
                                } catch (error) {
                                    console.error('❌ Error loading vein.frag shader:', error);
                                    console.error('🔍 Error type:', error.constructor.name);
                                    console.error('🔍 Error message:', error.message);
                                    console.error('🔍 Error stack:', error.stack);
                                    
                                    // エラーの種類によって詳細な情報を提供
                                    if (error instanceof TypeError) {
                                        console.error('🌐 Network error - check if server is running and file exists');
                                    } else if (error.message.includes('404')) {
                                        console.error('📂 File not found - /shaders/vein.frag does not exist');
                                        console.error('🔍 Check file path: /Users/mitsuishikaito/my_quantum_simulator_with_gpu/GUI/GUI/GUI.Web/wwwroot/shaders/vein.frag');
                                    } else if (error.message.includes('403')) {
                                        console.error('🔒 Access forbidden - check file permissions');
                                    } else if (error.message.includes('500')) {
                                        console.error('🔥 Server error - check server logs');
                                    }
                                    
                                    throw error;
                                }
                            },

                            getEmbeddedQuantumShader: function() {
                                // 緊急時フォールバック用のシンプルなシェーダー
                                // 通常は vein.frag から読み込むので、これは使われないはず
                                console.log('⚠️ Using emergency fallback shader - vein.frag failed to load');
                                return `
                                    precision highp float;
                                    uniform float time;
                                    uniform vec2 resolution;
                                    uniform float volume;
                                    
                                    void main() {
                                        vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;
                                        
                                        // シンプルな動的グラデーション
                                        float t = time * 0.001;
                                        vec3 col = vec3(
                                            0.2 + 0.3 * sin(t + uv.x * 3.0),
                                            0.1 + 0.2 * sin(t * 1.3 + uv.y * 2.0), 
                                            0.4 + 0.3 * sin(t * 0.7 + length(uv) * 4.0)
                                        );
                                        
                                        // ボリューム反映
                                        col *= (0.5 + 0.5 * volume);
                                        
                                        gl_FragColor = vec4(col, 1.0);
                                    }
                                `;
                            },
                            
                            setupCustomWebGLRenderer: function(canvas, fragmentShader) {
                                console.log('🎬 setupCustomWebGLRenderer called');
                                
                                // デバッグ表示を更新する関数をローカルで定義
                                const updateDebugStatus = (id, status) => {
                                    const element = document.getElementById(id);
                                    if (element) element.textContent = status;
                                };
                                
                                try {
                                    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                                    if (!gl) {
                                        console.error('❌ WebGL context not available');
                                        this.createSimpleBackground(canvas);
                                        return;
                                    }
                                    
                                    console.log('✅ WebGL context ready for custom renderer');
                                    
                                    // 初期キャンバスサイズを設定
                                    canvas.width = window.innerWidth;
                                    canvas.height = window.innerHeight;
                                    
                                    // キャンバスを背景として配置
                                    canvas.style.position = 'fixed';
                                    canvas.style.top = '0px';
                                    canvas.style.left = '0px';
                                    canvas.style.width = '100vw';
                                    canvas.style.height = '100vh';
                                    canvas.style.zIndex = '-1'; // 背景として配置（他の要素の下に）
                                    canvas.style.pointerEvents = 'none';
                                    canvas.style.display = 'block';
                                    canvas.style.visibility = 'visible';
                                    canvas.style.opacity = '1.0';
                                    canvas.style.backgroundColor = 'transparent';
                                    canvas.style.border = 'none';
                                    
                                    gl.viewport(0, 0, canvas.width, canvas.height);
                                    console.log('📐 Initial canvas size:', canvas.width, 'x', canvas.height);
                                    console.log('🎯 Canvas positioning complete');
                                    
                                    // シェーダーコンパイル
                                    const vertexShaderSource = `
                                        attribute vec2 a_position;
                                        void main() {
                                            gl_Position = vec4(a_position, 0.0, 1.0);
                                        }
                                    `;
                                    
                                    const createShader = (type, source) => {
                                        const shader = gl.createShader(type);
                                        gl.shaderSource(shader, source);
                                        gl.compileShader(shader);
                                        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                                            const error = gl.getShaderInfoLog(shader);
                                            console.error('💥 Shader compilation error:', error);
                                            console.error('🔍 Shader source (first 500 chars):', source.substring(0, 500));
                                            updateDebugStatus('shaderStatus', 'Compile error ❌');
                                            gl.deleteShader(shader);
                                            return null;
                                        }
                                        console.log('✅ Shader compiled successfully');
                                        return shader;
                                    };
                                    
                                    console.log('🔨 Compiling vertex shader...');
                                    const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
                                    
                                    console.log('🔨 Compiling fragment shader...');
                                    console.log('📊 Fragment shader length:', fragmentShader.length, 'characters');
                                    console.log('🔍 Shader source analysis:');
                                    console.log('  - Is vein.frag content:', fragmentShader.includes('RAYMARCH_SURFACE_DIST') && fragmentShader.includes('rayMarch'));
                                    console.log('  - Has complex 3D math:', fragmentShader.includes('getDist') && fragmentShader.includes('tunnel'));
                                    console.log('  - Is simple fallback:', fragmentShader.includes('emergency fallback'));
                                    
                                    if (fragmentShader.includes('RAYMARCH_SURFACE_DIST')) {
                                        console.log('✨ Using FULL vein.frag shader with ray marching!');
                                    } else {
                                        console.log('⚠️ Using simple emergency fallback shader');
                                    }
                                    
                                    console.log('  - Shader preview (first 150 chars):', fragmentShader.substring(0, 150).replace(/\s+/g, ' '));
                                    
                                    const fragShader = createShader(gl.FRAGMENT_SHADER, fragmentShader);
                                    
                                    if (!vertexShader || !fragShader) {
                                        console.error('❌ Shader compilation failed');
                                        this.createSimpleBackground(canvas);
                                        return;
                                    }
                                    
                                    console.log('✅ Shaders compiled successfully');
                                    updateDebugStatus('shaderStatus', 'Compiled ✅');
                                    
                                    // プログラム作成
                                    const program = gl.createProgram();
                                    gl.attachShader(program, vertexShader);
                                    gl.attachShader(program, fragShader);
                                    gl.linkProgram(program);
                                    
                                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                                        console.error('💥 Program linking error:', gl.getProgramInfoLog(program));
                                        this.createSimpleBackground(canvas);
                                        return;
                                    }
                                    
                                    console.log('✅ Shader program linked successfully');
                                    
                                    // バッファ設定
                                    const positionBuffer = gl.createBuffer();
                                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                                    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
                                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                                    
                                    // アトリビュート設定
                                    const positionLocation = gl.getAttribLocation(program, 'a_position');
                                    gl.enableVertexAttribArray(positionLocation);
                                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                                    
                                    // ユニフォーム取得（JSでは分かりやすい名前を使用、シェーダー内のuniform名と対応）
                                    const Time = gl.getUniformLocation(program, 'time');
                                    const Resolution = gl.getUniformLocation(program, 'resolution');
                                    const Volume = gl.getUniformLocation(program, 'volume');

                                    console.log('🎭 Uniforms located:', {
                                        Time: Time,
                                        Resolution: Resolution,
                                        Volume: Volume
                                    });
                                    
                                    let frameCount = 0;
                                    
                                    // レンダリング関数
                                    const render = (time) => {
                                        frameCount++;
                                        
                                        // フレームカウントを表示に更新
                                        const frameCountElement = document.getElementById('frameCount');
                                        if (frameCountElement) {
                                            frameCountElement.textContent = frameCount;
                                        }
                                        
                                        // 定期的にフレームカウントを出力
                                        if (frameCount % 60 === 0) {
                                            console.log('🎞️ Frames rendered:', frameCount, 'Time:', time.toFixed(2));
                                        }
                                        
                                        // サイズ調整
                                        if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                                            canvas.width = window.innerWidth;
                                            canvas.height = window.innerHeight;
                                            gl.viewport(0, 0, canvas.width, canvas.height);
                                        }
                                        
                                        // 背景をクリア（深い宇宙色）
                                        gl.clearColor(0.02, 0.05, 0.15, 1.0);
                                        gl.clear(gl.COLOR_BUFFER_BIT);
                                        
                                        // 描画
                                        try {
                                            gl.useProgram(program);
                                            gl.uniform1f(Time, time * 0.001);
                                            gl.uniform2f(Resolution, canvas.width, canvas.height);
                                            
                                            // volume uniformの設定（0.0〜1.0の値、動的に変化可能）
                                            const volumeValue = 0.5 + 0.3 * Math.sin(time * 0.002); // 時間で変化する例
                                            gl.uniform1f(Volume, volumeValue);
                                            

                                            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                                        } catch (shaderError) {
                                            console.warn('⚠️ Shader rendering failed:', shaderError);
                                        }
                                        requestAnimationFrame(render);
                                    };
                                    
                                    // レンダリング開始
                                    console.log('🚀 Starting render loop...');
                                    requestAnimationFrame(render);
                                    
                                    // リサイズ対応
                                    window.addEventListener('resize', () => {
                                        canvas.width = window.innerWidth;
                                        canvas.height = window.innerHeight;
                                        gl.viewport(0, 0, canvas.width, canvas.height);
                                        console.log('📐 Canvas resized:', canvas.width, 'x', canvas.height);
                                    });
                                    
                                    console.log('🎉 Custom WebGL quantum background initialized successfully!');
                                    
                                } catch (error) {
                                    console.error('💥 Custom WebGL setup failed:', error);
                                    console.error('Stack trace:', error.stack);
                                    this.createSimpleBackground(canvas);
                                }
                            },
                            
                            createSimpleBackground: function(canvas) {
                                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                                if (!gl) return;
                                
                                const updateSize = () => {
                                    canvas.width = window.innerWidth;
                                    canvas.height = window.innerHeight;
                                    gl.viewport(0, 0, canvas.width, canvas.height);
                                };
                                updateSize();
                                window.addEventListener('resize', updateSize);
                                
                                // 簡単なグラデーション背景
                                const animate = () => {
                                    const time = Date.now() * 0.001;
                                    const r = 0.1 + 0.1 * Math.sin(time * 0.5);
                                    const g = 0.2 + 0.1 * Math.sin(time * 0.7);
                                    const b = 0.4 + 0.2 * Math.sin(time * 0.3);
                                    
                                    gl.clearColor(r, g, b, 1.0);
                                    gl.clear(gl.COLOR_BUFFER_BIT);
                                    requestAnimationFrame(animate);
                                };
                                animate();
                                console.log('Simple background initialized');
                            },
                            
                            initialize: function() {
                                console.log('🚀 Initializing heartbeat dashboard...');
                                
                                // デバッグ表示を更新
                                const updateDebugStatus = (id, status) => {
                                    const element = document.getElementById(id);
                                    if (element) element.textContent = status;
                                };
                                
                                updateDebugStatus('jsStatus', 'Loaded ✅');
                                
                                // 背景色を強制的にクリア（デバッグ）
                                document.body.style.background = 'transparent';
                                document.body.style.backgroundColor = 'transparent';
                                document.documentElement.style.background = 'transparent';
                                document.documentElement.style.backgroundColor = 'transparent';
                                console.log('🎨 Background colors forcefully cleared');
                                
                                // デバッグ情報
                                console.log('Window size:', window.innerWidth, 'x', window.innerHeight);
                                console.log('User agent:', navigator.userAgent);
                                
                                // ハートアイコンのアニメーション
                                const heartIcon = document.querySelector('.heart-icon');
                                if (heartIcon) {
                                    heartIcon.style.animation = 'heartbeat 1.2s ease-in-out infinite';
                                    console.log('❤️ Heart icon animation applied');
                                } else {
                                    console.warn('⚠️ Heart icon not found');
                                }
                                
                                // キャンバス要素の確認・作成
                                let canvas = document.getElementById('vedaCanvas');
                                if (!canvas) {
                                    // キャンバスが存在しない場合は作成
                                    console.log('🎨 Canvas not found, creating new canvas element');
                                    canvas = document.createElement('canvas');
                                    canvas.id = 'vedaCanvas';
                                    canvas.className = 'veda-canvas';
                                } else {
                                    console.log('🎨 Canvas found:', canvas.width, 'x', canvas.height);
                                }
                                
                                updateDebugStatus('canvasStatus', 'Found/Created ✅');
                                
                                if (canvas) {
                                    // 詳細なDOM構造とスタイル情報を出力
                                    console.log('🔍 Canvas parent:', canvas.parentElement);
                                    console.log('🔍 Canvas siblings:', Array.from(canvas.parentElement?.children || []));
                                    console.log('🔍 Document body style:', {
                                        background: window.getComputedStyle(document.body).background,
                                        backgroundColor: window.getComputedStyle(document.body).backgroundColor
                                    });
                                    console.log('🔍 HTML style:', {
                                        background: window.getComputedStyle(document.documentElement).background,
                                        backgroundColor: window.getComputedStyle(document.documentElement).backgroundColor
                                    });
                                    
                                    // キャンバスのスタイルを背景用に設定
                                    canvas.style.position = 'fixed';
                                    canvas.style.top = '0';
                                    canvas.style.left = '0';
                                    canvas.style.width = '100vw';
                                    canvas.style.height = '100vh';
                                    canvas.style.zIndex = '-1'; // 背景として配置（他の要素の下に）
                                    canvas.style.pointerEvents = 'none';
                                    canvas.style.display = 'block';
                                    canvas.style.visibility = 'visible';
                                    canvas.style.opacity = '1';
                                    canvas.style.backgroundColor = 'transparent';
                                    canvas.style.border = 'none';
                                    
                                    // 親要素のスタイルも適切に設定
                                    if (canvas.parentElement) {
                                        canvas.parentElement.style.position = 'relative';
                                        canvas.parentElement.style.overflow = 'visible';
                                    }
                                    
                                    // 親要素から切り離してbodyに直接追加（確実に最前面に）
                                    document.body.appendChild(canvas);
                                    console.log('🔄 Canvas moved/added to body');
                                    
                                    console.log('🎨 Canvas style forcefully applied');
                                    console.log('🔍 Final canvas computed style:', {
                                        position: window.getComputedStyle(canvas).position,
                                        zIndex: window.getComputedStyle(canvas).zIndex,
                                        width: window.getComputedStyle(canvas).width,
                                        height: window.getComputedStyle(canvas).height,
                                        visibility: window.getComputedStyle(canvas).visibility,
                                        display: window.getComputedStyle(canvas).display,
                                        backgroundColor: window.getComputedStyle(canvas).backgroundColor,
                                        opacity: window.getComputedStyle(canvas).opacity
                                    });
                                    
                                    // キャンバスの位置を視覚的に確認
                                    const rect = canvas.getBoundingClientRect();
                                    console.log('📐 Canvas position:', {
                                        top: rect.top,
                                        left: rect.left,
                                        width: rect.width,
                                        height: rect.height,
                                        visible: rect.width > 0 && rect.height > 0
                                    });
                                    
                                    // 即座にサイズ設定
                                    canvas.width = window.innerWidth;
                                    canvas.height = window.innerHeight;
                                    console.log('📐 Canvas resized to:', canvas.width, 'x', canvas.height);
                                } else {
                                    console.error('❌ Canvas element could not be found or created!');
                                    updateDebugStatus('canvasStatus', 'Creation failed ❌');
                                }
                                
                                // 背景エフェクトを少し遅延させて初期化（DOM確実に準備されるように）
                                setTimeout(() => {
                                    console.log('🌌 Starting background initialization...');
                                    this.initializeVedaBackground();
                                }, 100);
                                
                                // 初期アニメーション
                                setTimeout(() => {
                                    this.animateMetrics();
                                }, 200);
                            },
                            
                            cleanup: function() {
                                this.stopRealTimeUpdate();
                                console.log('Heartbeat cleanup completed');
                            }
                        };
                    ");
                }
                
                // JavaScript関数の存在確認後に初期化
                var initializeExists = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.heartbeatInterop !== 'undefined' && typeof window.heartbeatInterop.initialize === 'function'");
                
                if (initializeExists)
                {
                    // JavaScriptの初期化
                    await JSRuntime.InvokeVoidAsync("heartbeatInterop.initialize");
                }
                else
                {
                    // Heartbeatページ以外では警告を表示しない
                    var currentPath = NavigationManager.ToBaseRelativePath(NavigationManager.Uri);
                    if (currentPath.StartsWith("heartbeat"))
                    {
                        Console.WriteLine("heartbeatInterop.initialize is not available");
                    }
                }
                
                // リアルタイム更新は不要なので削除
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript initialization failed: {ex.Message}");
            }
        }
        else
        {
            try
            {
                // heartbeatInteropオブジェクトが存在するかチェック
                var functionExists = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.heartbeatInterop !== 'undefined' && typeof window.heartbeatInterop.animateMetrics === 'function'");
                
                if (functionExists)
                {
                    // データ更新後にJavaScript関数を呼び出し
                    await JSRuntime.InvokeVoidAsync("heartbeatInterop.animateMetrics");
                }
                else
                {
                    // Heartbeatページ以外では警告を表示しない
                    var currentPath = NavigationManager.ToBaseRelativePath(NavigationManager.Uri);
                    if (currentPath.StartsWith("heartbeat"))
                    {
                        Console.WriteLine("heartbeatInterop.animateMetrics is not yet available");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript update failed: {ex.Message}");
            }
        }
    }

    [JSInvokable]
    public async Task UpdateHeartbeatData()
    {
        await LoadHeartbeatData();
        StateHasChanged();
    }

    private async Task LoadHeartbeatData()
    {
        // 単純な初期化のみ
        await Task.Delay(100);
        
        currentStatus = new HeartbeatInfo
        {
            IsHealthy = true
        };
    }

    private async Task LoadSimulationResult()
    {
        try
        {
            Console.WriteLine("🔍 LoadSimulationResult called");
            
            // 1. まず最新の結果ファイルから読み込み（最新の結果を優先）
            var tempDir = Path.Combine(Path.GetTempPath(), "qmdd_gui_results");
            var resultFile = Path.Combine(tempDir, "latest_simulation_result.json");
            
            Console.WriteLine($"🔍 Checking for result file: {resultFile}");
            
            if (File.Exists(resultFile))
            {
                var fileInfo = new FileInfo(resultFile);
                Console.WriteLine($"📁 File found, last modified: {fileInfo.LastWriteTime}");
                
                var fileResultJson = await File.ReadAllTextAsync(resultFile);
                
                simulationResult = JsonSerializer.Deserialize<SimulationResultData>(fileResultJson, 
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    
                Console.WriteLine($"✅ Loaded simulation result from file: {simulationResult.GateCount} gates, DetailedLog count: {simulationResult.DetailedLog?.Count ?? 0}");
                
                // 詳細ログの内容を確認
                if (simulationResult.DetailedLog?.Count > 0)
                {
                    var firstLog = simulationResult.DetailedLog[0];
                    Console.WriteLine($"📊 First DetailedLog entry: Gate={firstLog.GateNumber}, Weight={firstLog.CurrentGate.Weight}, Key={firstLog.CurrentGate.Key}");
                }
                
                // ファイルから読み込んだ結果をセッションストレージにも保存
                await JSRuntime.InvokeVoidAsync("sessionStorage.setItem", "simulationResult", fileResultJson);
                Console.WriteLine("💾 Updated session storage with file result");
                return;
            }

            // 2. ファイルがない場合はセッションストレージから試行
            var sessionResultJson = await JSRuntime.InvokeAsync<string>("sessionStorage.getItem", "simulationResult");
            if (!string.IsNullOrEmpty(sessionResultJson))
            {
                simulationResult = JsonSerializer.Deserialize<SimulationResultData>(sessionResultJson, 
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                
                Console.WriteLine($"✅ Loaded simulation result from session storage: {simulationResult.GateCount} gates, DetailedLog count: {simulationResult.DetailedLog?.Count ?? 0}");
                return;
            }

            Console.WriteLine("❌ No simulation result found in file system or session storage");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to load simulation result: {ex.Message}");
        }
    }

    private async Task RunNewSimulation()
    {
        // セッションストレージをクリア
        await JSRuntime.InvokeVoidAsync("sessionStorage.removeItem", "simulationResult");
        
        // Composerページに移動
        NavigationManager.NavigateTo("/composer");
    }

    private void GoToComposer()
    {
        NavigationManager.NavigateTo("/composer");
    }

    public void Dispose()
    {
        try
        {
            // キャンセレーショントークンをキャンセル
            _cancellationTokenSource.Cancel();
            _cancellationTokenSource.Dispose();
            
            // リアルタイム更新を停止（存在確認は省略、cleanup時なのでエラー無視）
            _ = JSRuntime.InvokeVoidAsync("heartbeatInterop.cleanup");
            dotNetRef?.Dispose();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Cleanup failed: {ex.Message}");
        }
    }

    private class HeartbeatInfo
    {
        public bool IsHealthy { get; set; }
    }

    private class SimulationResultData
    {
        public bool Success { get; set; }
        public int GateCount { get; set; }
        public double ExecutionTime { get; set; }
        public List<GateExecutionInfo> Gates { get; set; } = new();
        public string Timestamp { get; set; } = string.Empty;
        public string FinalState { get; set; } = string.Empty;
        public List<GateLogEntry> DetailedLog { get; set; } = new();
    }

    private class GateExecutionInfo
    {
        public int GateNumber { get; set; }
        public string Type { get; set; } = string.Empty;
        public string Label { get; set; } = string.Empty;
        public List<int> Qubits { get; set; } = new();
        public List<int>? ControlQubits { get; set; }
    }

    private class GateLogEntry
    {
        public int GateNumber { get; set; }
        public string GateLabel { get; set; } = string.Empty;
        public string GateType { get; set; } = string.Empty;
        public List<int> Qubits { get; set; } = new();
        public List<int>? ControlQubits { get; set; }
        public QMDDGateInfo CurrentGate { get; set; } = new();
        public QMDDStateInfo CurrentState { get; set; } = new();
    }

    private class QMDDGateInfo
    {
        public string Weight { get; set; } = string.Empty;
        public string Key { get; set; } = string.Empty;
        public int IsTerminal { get; set; }
    }

    private class QMDDStateInfo
    {
        public string Weight { get; set; } = string.Empty;
        public string Key { get; set; } = string.Empty;
        public int IsTerminal { get; set; }
    }
}