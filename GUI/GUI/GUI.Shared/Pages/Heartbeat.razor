@page "/heartbeat"
@inject IJSRuntime JSRuntime
@implements IDisposable
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components

<PageTitle>Heartbeat</PageTitle>

<!-- å®Œå…¨çµ±åˆå®Ÿè£…ï¼šCSS + JavaScript + HTML + Veda.js Background -->
<style>
/* ãƒšãƒ¼ã‚¸å…¨ä½“ã®èƒŒæ™¯ã‚’é€æ˜ã«ã™ã‚‹ */
body, html {
    background: transparent !important;
    background-color: transparent !important;
}

/* Blazor Serverã®æ—¢å­˜èƒŒæ™¯ã‚’ç„¡åŠ¹åŒ–ï¼ˆã‚µã‚¤ãƒ‰ãƒãƒ¼ã¯é™¤ãï¼‰ */
.main, .content, .page {
    background: transparent !important;
    background-color: transparent !important;
}

/* ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®èƒŒæ™¯ã‚’ä¿æŒ */
.sidebar {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%) !important; /* ä»–ã®ãƒšãƒ¼ã‚¸ã¨åŒã˜ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
    background-color: rgb(5, 39, 103) !important;
}

/* ã‚µã‚¤ãƒ‰ãƒãƒ¼å†…ã®è¦ç´ ã®èƒŒæ™¯ã‚‚é©åˆ‡ã«è¨­å®š */
.sidebar .nav-item {
    background: transparent;
}

.sidebar .nav-item.active {
    background: rgba(255, 255, 255, 0.1) !important;
}

.sidebar .nav-link {
    color: white !important;
}

.sidebar .nav-link:hover {
    background: rgba(255, 255, 255, 0.1) !important;
}

/* ã‚ˆã‚Šå…·ä½“çš„ãªã‚µã‚¤ãƒ‰ãƒãƒ¼èƒŒæ™¯è¨­å®š */
nav.navbar, .navbar-dark, .bg-dark {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%) !important;
    background-color: rgb(5, 39, 103) !important;
}

/* ãƒˆãƒƒãƒ—è¡Œã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã¯é™¤å¤– */
.sidebar .top-row.navbar,
.top-row.navbar-dark {
    background: rgba(0,0,0,0.4) !important;
    background-color: rgba(0,0,0,0.4) !important;
    background-image: none !important;
}

/* æœ€å„ªå…ˆã§ãƒˆãƒƒãƒ—è¡Œã®èƒŒæ™¯ã‚’åŠé€æ˜é»’ã«å¼·åˆ¶å¤‰æ›´ */
.sidebar .top-row.ps-3.navbar.navbar-dark,
div.sidebar div.top-row,
.sidebar > .top-row {
    background: rgba(0,0,0,0.4) !important;
    background-color: rgba(0,0,0,0.4) !important;
    background-image: none !important;
}

/* ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ãƒˆãƒƒãƒ—è¡Œã¯å…ƒã®åŠé€æ˜èƒŒæ™¯ã‚’ç¶­æŒ - ã‚ˆã‚Šå¼·åŠ›ãªã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ */
.sidebar .top-row,
.top-row.ps-3.navbar.navbar-dark,
.navbar-dark.top-row {
    background: rgba(0,0,0,0.4) !important;
    background-color: rgba(0,0,0,0.4) !important;
    background-image: none !important;
}

/* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã®ãƒ–ãƒ©ãƒ³ãƒ‰ */
.navbar-brand {
    color: white !important;
}

/* ã‚µã‚¤ãƒ‰ãƒãƒ¼å…¨ä½“ã®ã‚¹ã‚¿ã‚¤ãƒ«ä¿æŒ */
.sidebar-content, .nav-scrollable {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%) !important;
    background-color: rgb(5, 39, 103) !important;
}

/* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³é …ç›® */
.nav-item .nav-link.active {
    background: rgba(255, 255, 255, 0.2) !important;
    color: white !important;
}

/* ãƒ›ãƒãƒ¼åŠ¹æœ */
.nav-item .nav-link:hover {
    background: rgba(255, 255, 255, 0.1) !important;
    color: white !important;
}

/* Veda.js èƒŒæ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
.veda-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    overflow: hidden;
    pointer-events: none;
}

.veda-canvas {
    width: 100vw !important;
    height: 100vh !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    z-index: -1 !important;
    background: transparent;
    object-fit: cover;
    display: block !important;
}

/* ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¦ç´ ã‚’èƒŒæ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä¸Šã«é…ç½® */
.status-dashboard {
    position: relative;
    z-index: 2;
    background: rgba(255, 255, 255, 0.75); // èƒŒæ™¯ã‚’é€æ˜ã«ã—ã¦é‡å­å›è·¯ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«
    backdrop-filter: blur(8px); // ã‚¬ãƒ©ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å¼·åŒ–
    border-radius: 16px;
    padding: 20px;
    margin: 20px;
}

/* ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
.heart-icon {
    animation: heartbeat 1.2s ease-in-out infinite !important;
    color: #e74c3c !important;
    fill: #e74c3c !important;
    filter: drop-shadow(0 0 5px rgba(231, 76, 60, 0.5));
    transform-origin: center !important;
    display: inline-block !important;
    transition: none !important;
}

.heart-icon:hover {
    animation: heartbeat-fast 0.8s ease-in-out infinite !important;
    filter: drop-shadow(0 0 8px rgba(231, 76, 60, 0.8));
}

.heart-icon path {
    fill: currentColor !important;
}

.card {
    /* From https://css.glass */
    background: rgba(255, 255, 255, 0.2);
    border-radius: 16px;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

@@keyframes heartbeat {
    0% { 
        transform: scale(1); 
    }
    14% { 
        transform: scale(1.3); 
    }
    28% { 
        transform: scale(1); 
    }
    42% { 
        transform: scale(1.3); 
    }
    70% { 
        transform: scale(1); 
    }
    100% { 
        transform: scale(1); 
    }
}

@@keyframes heartbeat-fast {
    0% { 
        transform: scale(1); 
    }
    50% { 
        transform: scale(1.4); 
    }
    100% { 
        transform: scale(1); 
    }
}

/* æ—¢å­˜ã®ã‚¹ã‚¿ã‚¤ãƒ« */
h1 {
    display: flex;
    align-items: center;
    gap: 10px;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ */
@@media (max-width: 768px) {
    /* å‰Šé™¤æ¸ˆã¿ */
}
</style>

<h1>
    <svg class="heart-icon" viewBox="0 0 24 24" width="32" height="32">
        <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="currentColor"/>
    </svg>
    Heartbeat
</h1>

<p>ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–</p>

<!-- Veda.js ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼èƒŒæ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ -->
<!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ã¯JavaScriptã§å‹•çš„ã«ä½œæˆã—ã¦bodyã«è¿½åŠ ã™ã‚‹ãŸã‚ã€ã“ã“ã«ã¯é…ç½®ã—ãªã„ -->
<!--<div class="veda-background">
    <canvas id="vedaCanvas" class="veda-canvas"></canvas>
</div>-->

<!-- ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º (éè¡¨ç¤º) -->
<div id="debugInfo" style="display: none; position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: white; padding: 8px; border-radius: 8px; font-family: monospace; font-size: 11px; z-index: 1000; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1);">
    <div style="color: #4ade80;">ğŸ”§ JS: <span id="jsStatus">Loading...</span></div>
    <div style="color: #60a5fa;">ğŸ¨ Canvas: <span id="canvasStatus">Checking...</span></div>
    <div style="color: #a78bfa;">ğŸŒŒ WebGL: <span id="webglStatus">Testing...</span></div>
    <div style="color: #f472b6;">ğŸ§¬ Shader: <span id="shaderStatus">Loading...</span></div>
    <div style="color: #fbbf24;">â±ï¸ Frames: <span id="frameCount">0</span></div>
</div>

@if (currentStatus == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <!-- ã‚·ãƒ³ãƒ—ãƒ«ãªé‡å­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿èƒŒæ™¯ã®ã¿ -->
}

@code {
    private HeartbeatInfo? currentStatus;
    private DotNetObjectReference<object>? dotNetRef;

    protected override async Task OnInitializedAsync()
    {
        // DotNetObjectReferenceã‚’ä½œæˆ
        dotNetRef = DotNetObjectReference.Create<object>(this);
        
        // åˆæœŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        await LoadHeartbeatData();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // JavaScriptã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèªã—ã¦ã‹ã‚‰åˆæœŸåŒ–
                var objectExists = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.heartbeatInterop !== 'undefined'");
                
                if (!objectExists)
                {
                    // heartbeatInteropã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                    await JSRuntime.InvokeVoidAsync("eval", @"
                        // Heartbeatç”¨ã®JavaScriptã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                        window.heartbeatInterop = {
                            updateInterval: null,
                            vedaInstance: null,
                            
                            startRealTimeUpdate: function(dotNetObjectReference) {
                                console.log('Starting real-time heartbeat updates...');
                                this.updateInterval = setInterval(() => {
                                    try {
                                        dotNetObjectReference.invokeMethodAsync('UpdateHeartbeatData');
                                    } catch (error) {
                                        console.error('Failed to update heartbeat data:', error);
                                    }
                                }, 3000);
                            },
                            
                            stopRealTimeUpdate: function() {
                                if (this.updateInterval) {
                                    clearInterval(this.updateInterval);
                                    this.updateInterval = null;
                                }
                            },
                            
                            animateMetrics: function() {
                                // ãƒ¡ãƒˆãƒªã‚¯ã‚¹é–¢é€£ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯å‰Šé™¤æ¸ˆã¿
                                console.log('Metrics animation skipped (metrics removed)');
                            },
                            
                            initializeVedaBackground: function() {
                                console.log('ğŸ¯ initializeVedaBackground called');
                                
                                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
                                let canvas = document.getElementById('vedaCanvas');
                                if (!canvas) {
                                    console.log('âŒ Veda canvas not found, creating new canvas');
                                    canvas = document.createElement('canvas');
                                    canvas.id = 'vedaCanvas';
                                    canvas.className = 'veda-canvas';
                                    document.body.appendChild(canvas);
                                    console.log('âœ… New canvas created and added to body');
                                } else {
                                    console.log('âœ… Canvas element found:', canvas);
                                }
                                
                                console.log('ğŸ“Š Canvas dimensions:', canvas.width, 'x', canvas.height);
                                console.log('ğŸ¨ Canvas style:', window.getComputedStyle(canvas));
                                
                                // ç›´æ¥ã‚«ã‚¹ã‚¿ãƒ WebGLãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚’ä½¿ç”¨
                                this.setupVedaShader(canvas);
                            },
                            
                            loadVedaJS: function() {
                                return new Promise((resolve, reject) => {
                                    if (window.VEDA) {
                                        resolve(window.VEDA);
                                        return;
                                    }
                                    
                                    const script = document.createElement('script');
                                    script.src = 'https://unpkg.com/vedajs@1.3.3/lib/veda.js';
                                    script.onload = () => {
                                        console.log('Veda.js loaded successfully');
                                        resolve(window.VEDA);
                                    };
                                    script.onerror = (error) => {
                                        console.error('Failed to load Veda.js:', error);
                                        reject(error);
                                    };
                                    document.head.appendChild(script);
                                });
                            },
                            
                            setupVedaShader: function(canvas) {
                                console.log('ğŸ”§ setupVedaShader called with canvas:', canvas);
                                
                                // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§å®šç¾©
                                const updateDebugStatus = (id, status) => {
                                    const element = document.getElementById(id);
                                    if (element) element.textContent = status;
                                };
                                
                                try {
                                    // ã¾ãšåŸºæœ¬çš„ãªWebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ†ã‚¹ãƒˆ
                                    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                                    if (!gl) {
                                        console.warn('âš ï¸ WebGL not supported, falling back to simple background');
                                        updateDebugStatus('webglStatus', 'Not supported âŒ');
                                        this.createSimpleBackground(canvas);
                                        return;
                                    }
                                    
                                    console.log('âœ… WebGL context obtained:', gl);
                                    console.log('ğŸ” WebGL version:', gl.getParameter(gl.VERSION));
                                    console.log('ğŸ” WebGL renderer:', gl.getParameter(gl.RENDERER));
                                    updateDebugStatus('webglStatus', 'Supported âœ…');
                                    
                                    // å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆvein.fragï¼‰ã‚’æœ€å„ªå…ˆã§èª­ã¿è¾¼ã¿
                                    console.log('ğŸ¨ Loading vein.frag shader from external file...');
                                    console.log('ğŸ“‚ Primary source: /shaders/vein.frag');
                                    updateDebugStatus('shaderStatus', 'Loading external...');
                                    
                                    this.loadQuantumShader()
                                        .then(shaderSource => {
                                            console.log('ğŸ‰ ğŸ¨ External vein.frag loaded and validated successfully!');
                                            console.log('ğŸ“Š Using external shader with', shaderSource.length, 'characters');
                                            console.log('âœ¨ This is the REAL vein.frag content - not embedded!');
                                            updateDebugStatus('shaderStatus', 'External loaded âœ…');
                                            
                                            // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å‰ã®æœ€çµ‚ç¢ºèª
                                            console.log('ğŸ”¥ About to compile external vein.frag shader...');
                                            this.setupCustomWebGLRenderer(canvas, shaderSource);
                                        })
                                        .catch(error => {
                                            console.log('âš ï¸ ğŸ”´ External vein.frag loading failed, using emergency fallback');
                                            console.log('ğŸ” Failure reason:', error.message);
                                            console.log('ğŸ“‹ Full error details:', error);
                                            updateDebugStatus('shaderStatus', 'Fallback to simple âš ï¸');
                                            
                                            console.log('ğŸ”„ Loading simple emergency fallback shader...');
                                            const embeddedShader = this.getEmbeddedQuantumShader();
                                            console.log('ğŸ“Š Using emergency fallback with', embeddedShader.length, 'characters');
                                            console.log('âš ï¸ This is NOT the full vein.frag - just a simple backup!');
                                            console.log('ğŸ”¥ About to compile emergency fallback shader...');
                                            this.setupCustomWebGLRenderer(canvas, embeddedShader);
                                        });
                                        
                                        
                                } catch (error) {
                                    console.error('ğŸ’¥ Shader setup failed:', error);
                                    updateDebugStatus('webglStatus', 'Error âŒ');
                                    this.createSimpleBackground(canvas);
                                }
                            },
                            
                            loadQuantumShader: async function() {
                                console.log('ğŸ“‚ Fetching quantum shader from /shaders/vein.frag');
                                console.log('ğŸŒ Current URL:', window.location.href);
                                console.log('ğŸ”— Shader URL:', window.location.origin + '/shaders/vein.frag');
                                
                                try {
                                    const response = await fetch('/shaders/vein.frag');
                                    console.log('ğŸ“¡ Fetch response received:', response);
                                    console.log('ğŸ“Š Response status:', response.status, response.statusText);
                                    console.log('ğŸ“‹ Response headers:', [...response.headers.entries()]);
                                    console.log('ğŸ” Response type:', response.type);
                                    console.log('âœ… Response ok:', response.ok);
                                    
                                    if (!response.ok) {
                                        throw new Error(`Shader fetch failed: ${response.status} ${response.statusText}`);
                                    }
                                    
                                    const shaderSource = await response.text();
                                    console.log('ğŸ‰ âœ… vein.frag loaded successfully!');
                                    console.log('ğŸ“Š Shader length:', shaderSource.length, 'characters');
                                    console.log('ğŸ” First 200 chars:', shaderSource.substring(0, 200));
                                    console.log('ğŸ” Last 100 chars:', shaderSource.slice(-100));
                                    
                                    // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ä¸»è¦ãªç‰¹å¾´ã‚’æ¤œè¨¼
                                    const hasUniforms = shaderSource.includes('uniform float time') && 
                                                       shaderSource.includes('uniform vec2 resolution') && 
                                                       shaderSource.includes('uniform float volume');
                                    const hasMain = shaderSource.includes('void main()');
                                    const hasRayMarching = shaderSource.includes('rayMarch');
                                    const hasGetDist = shaderSource.includes('getDist');
                                    
                                    console.log('ğŸ”¬ Shader validation:');
                                    console.log('  - Has required uniforms:', hasUniforms);
                                    console.log('  - Has main function:', hasMain);
                                    console.log('  - Has ray marching:', hasRayMarching);
                                    console.log('  - Has distance function:', hasGetDist);
                                    
                                    if (!hasUniforms || !hasMain) {
                                        console.warn('âš ï¸ Shader may be incomplete or corrupted');
                                    } else {
                                        console.log('âœ… Shader validation passed - looks good!');
                                    }
                                    
                                    // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚½ãƒ¼ã‚¹ã‚’ãã®ã¾ã¾ä½¿ç”¨ï¼ˆVeda.jsæ¨™æº–uniformåã«å¯¾å¿œï¼‰
                                    const adjustedShaderSource = shaderSource;
                                    
                                    console.log('ğŸ”§ Using standard Veda.js uniform names (time, resolution, volume)');
                                    console.log('ğŸ¯ Final shader ready for compilation');
                                    return adjustedShaderSource;
                                } catch (error) {
                                    console.error('âŒ Error loading vein.frag shader:', error);
                                    console.error('ğŸ” Error type:', error.constructor.name);
                                    console.error('ğŸ” Error message:', error.message);
                                    console.error('ğŸ” Error stack:', error.stack);
                                    
                                    // ã‚¨ãƒ©ãƒ¼ã®ç¨®é¡ã«ã‚ˆã£ã¦è©³ç´°ãªæƒ…å ±ã‚’æä¾›
                                    if (error instanceof TypeError) {
                                        console.error('ğŸŒ Network error - check if server is running and file exists');
                                    } else if (error.message.includes('404')) {
                                        console.error('ğŸ“‚ File not found - /shaders/vein.frag does not exist');
                                        console.error('ğŸ” Check file path: /Users/mitsuishikaito/my_quantum_simulator_with_gpu/GUI/GUI/GUI.Web/wwwroot/shaders/vein.frag');
                                    } else if (error.message.includes('403')) {
                                        console.error('ğŸ”’ Access forbidden - check file permissions');
                                    } else if (error.message.includes('500')) {
                                        console.error('ğŸ”¥ Server error - check server logs');
                                    }
                                    
                                    throw error;
                                }
                            },

                            getEmbeddedQuantumShader: function() {
                                // ç·Šæ€¥æ™‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®ã‚·ãƒ³ãƒ—ãƒ«ãªã‚·ã‚§ãƒ¼ãƒ€ãƒ¼
                                // é€šå¸¸ã¯ vein.frag ã‹ã‚‰èª­ã¿è¾¼ã‚€ã®ã§ã€ã“ã‚Œã¯ä½¿ã‚ã‚Œãªã„ã¯ãš
                                console.log('âš ï¸ Using emergency fallback shader - vein.frag failed to load');
                                return `
                                    precision highp float;
                                    uniform float time;
                                    uniform vec2 resolution;
                                    uniform float volume;
                                    
                                    void main() {
                                        vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;
                                        
                                        // ã‚·ãƒ³ãƒ—ãƒ«ãªå‹•çš„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                                        float t = time * 0.001;
                                        vec3 col = vec3(
                                            0.2 + 0.3 * sin(t + uv.x * 3.0),
                                            0.1 + 0.2 * sin(t * 1.3 + uv.y * 2.0), 
                                            0.4 + 0.3 * sin(t * 0.7 + length(uv) * 4.0)
                                        );
                                        
                                        // ãƒœãƒªãƒ¥ãƒ¼ãƒ åæ˜ 
                                        col *= (0.5 + 0.5 * volume);
                                        
                                        gl_FragColor = vec4(col, 1.0);
                                    }
                                `;
                            },
                            
                            setupCustomWebGLRenderer: function(canvas, fragmentShader) {
                                console.log('ğŸ¬ setupCustomWebGLRenderer called');
                                
                                // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§å®šç¾©
                                const updateDebugStatus = (id, status) => {
                                    const element = document.getElementById(id);
                                    if (element) element.textContent = status;
                                };
                                
                                try {
                                    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                                    if (!gl) {
                                        console.error('âŒ WebGL context not available');
                                        this.createSimpleBackground(canvas);
                                        return;
                                    }
                                    
                                    console.log('âœ… WebGL context ready for custom renderer');
                                    
                                    // åˆæœŸã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’è¨­å®š
                                    canvas.width = window.innerWidth;
                                    canvas.height = window.innerHeight;
                                    
                                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’èƒŒæ™¯ã¨ã—ã¦é…ç½®
                                    canvas.style.position = 'fixed';
                                    canvas.style.top = '0px';
                                    canvas.style.left = '0px';
                                    canvas.style.width = '100vw';
                                    canvas.style.height = '100vh';
                                    canvas.style.zIndex = '-1'; // èƒŒæ™¯ã¨ã—ã¦é…ç½®ï¼ˆä»–ã®è¦ç´ ã®ä¸‹ã«ï¼‰
                                    canvas.style.pointerEvents = 'none';
                                    canvas.style.display = 'block';
                                    canvas.style.visibility = 'visible';
                                    canvas.style.opacity = '1.0';
                                    canvas.style.backgroundColor = 'transparent';
                                    canvas.style.border = 'none';
                                    
                                    gl.viewport(0, 0, canvas.width, canvas.height);
                                    console.log('ğŸ“ Initial canvas size:', canvas.width, 'x', canvas.height);
                                    console.log('ğŸ¯ Canvas positioning complete');
                                    
                                    // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
                                    const vertexShaderSource = `
                                        attribute vec2 a_position;
                                        void main() {
                                            gl_Position = vec4(a_position, 0.0, 1.0);
                                        }
                                    `;
                                    
                                    const createShader = (type, source) => {
                                        const shader = gl.createShader(type);
                                        gl.shaderSource(shader, source);
                                        gl.compileShader(shader);
                                        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                                            const error = gl.getShaderInfoLog(shader);
                                            console.error('ğŸ’¥ Shader compilation error:', error);
                                            console.error('ğŸ” Shader source (first 500 chars):', source.substring(0, 500));
                                            updateDebugStatus('shaderStatus', 'Compile error âŒ');
                                            gl.deleteShader(shader);
                                            return null;
                                        }
                                        console.log('âœ… Shader compiled successfully');
                                        return shader;
                                    };
                                    
                                    console.log('ğŸ”¨ Compiling vertex shader...');
                                    const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
                                    
                                    console.log('ğŸ”¨ Compiling fragment shader...');
                                    console.log('ğŸ“Š Fragment shader length:', fragmentShader.length, 'characters');
                                    console.log('ğŸ” Shader source analysis:');
                                    console.log('  - Is vein.frag content:', fragmentShader.includes('RAYMARCH_SURFACE_DIST') && fragmentShader.includes('rayMarch'));
                                    console.log('  - Has complex 3D math:', fragmentShader.includes('getDist') && fragmentShader.includes('tunnel'));
                                    console.log('  - Is simple fallback:', fragmentShader.includes('emergency fallback'));
                                    
                                    if (fragmentShader.includes('RAYMARCH_SURFACE_DIST')) {
                                        console.log('âœ¨ Using FULL vein.frag shader with ray marching!');
                                    } else {
                                        console.log('âš ï¸ Using simple emergency fallback shader');
                                    }
                                    
                                    console.log('  - Shader preview (first 150 chars):', fragmentShader.substring(0, 150).replace(/\s+/g, ' '));
                                    
                                    const fragShader = createShader(gl.FRAGMENT_SHADER, fragmentShader);
                                    
                                    if (!vertexShader || !fragShader) {
                                        console.error('âŒ Shader compilation failed');
                                        this.createSimpleBackground(canvas);
                                        return;
                                    }
                                    
                                    console.log('âœ… Shaders compiled successfully');
                                    updateDebugStatus('shaderStatus', 'Compiled âœ…');
                                    
                                    // ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä½œæˆ
                                    const program = gl.createProgram();
                                    gl.attachShader(program, vertexShader);
                                    gl.attachShader(program, fragShader);
                                    gl.linkProgram(program);
                                    
                                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                                        console.error('ğŸ’¥ Program linking error:', gl.getProgramInfoLog(program));
                                        this.createSimpleBackground(canvas);
                                        return;
                                    }
                                    
                                    console.log('âœ… Shader program linked successfully');
                                    
                                    // ãƒãƒƒãƒ•ã‚¡è¨­å®š
                                    const positionBuffer = gl.createBuffer();
                                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                                    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
                                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                                    
                                    // ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆè¨­å®š
                                    const positionLocation = gl.getAttribLocation(program, 'a_position');
                                    gl.enableVertexAttribArray(positionLocation);
                                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                                    
                                    // ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ å–å¾—ï¼ˆJSã§ã¯åˆ†ã‹ã‚Šã‚„ã™ã„åå‰ã‚’ä½¿ç”¨ã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼å†…ã®uniformåã¨å¯¾å¿œï¼‰
                                    const Time = gl.getUniformLocation(program, 'time');
                                    const Resolution = gl.getUniformLocation(program, 'resolution');
                                    const Volume = gl.getUniformLocation(program, 'volume');

                                    console.log('ğŸ­ Uniforms located:', {
                                        Time: Time,
                                        Resolution: Resolution,
                                        Volume: Volume
                                    });
                                    
                                    let frameCount = 0;
                                    
                                    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°
                                    const render = (time) => {
                                        frameCount++;
                                        
                                        // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆã‚’è¡¨ç¤ºã«æ›´æ–°
                                        const frameCountElement = document.getElementById('frameCount');
                                        if (frameCountElement) {
                                            frameCountElement.textContent = frameCount;
                                        }
                                        
                                        // å®šæœŸçš„ã«ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆã‚’å‡ºåŠ›
                                        if (frameCount % 60 === 0) {
                                            console.log('ğŸï¸ Frames rendered:', frameCount, 'Time:', time.toFixed(2));
                                        }
                                        
                                        // ã‚µã‚¤ã‚ºèª¿æ•´
                                        if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                                            canvas.width = window.innerWidth;
                                            canvas.height = window.innerHeight;
                                            gl.viewport(0, 0, canvas.width, canvas.height);
                                        }
                                        
                                        // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢ï¼ˆæ·±ã„å®‡å®™è‰²ï¼‰
                                        gl.clearColor(0.02, 0.05, 0.15, 1.0);
                                        gl.clear(gl.COLOR_BUFFER_BIT);
                                        
                                        // æç”»
                                        try {
                                            gl.useProgram(program);
                                            gl.uniform1f(Time, time * 0.001);
                                            gl.uniform2f(Resolution, canvas.width, canvas.height);
                                            
                                            // volume uniformã®è¨­å®šï¼ˆ0.0ã€œ1.0ã®å€¤ã€å‹•çš„ã«å¤‰åŒ–å¯èƒ½ï¼‰
                                            const volumeValue = 0.5 + 0.3 * Math.sin(time * 0.002); // æ™‚é–“ã§å¤‰åŒ–ã™ã‚‹ä¾‹
                                            gl.uniform1f(Volume, volumeValue);
                                            

                                            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                                        } catch (shaderError) {
                                            console.warn('âš ï¸ Shader rendering failed:', shaderError);
                                        }
                                        requestAnimationFrame(render);
                                    };
                                    
                                    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹
                                    console.log('ğŸš€ Starting render loop...');
                                    requestAnimationFrame(render);
                                    
                                    // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
                                    window.addEventListener('resize', () => {
                                        canvas.width = window.innerWidth;
                                        canvas.height = window.innerHeight;
                                        gl.viewport(0, 0, canvas.width, canvas.height);
                                        console.log('ğŸ“ Canvas resized:', canvas.width, 'x', canvas.height);
                                    });
                                    
                                    console.log('ğŸ‰ Custom WebGL quantum background initialized successfully!');
                                    
                                } catch (error) {
                                    console.error('ğŸ’¥ Custom WebGL setup failed:', error);
                                    console.error('Stack trace:', error.stack);
                                    this.createSimpleBackground(canvas);
                                }
                            },
                            
                            createSimpleBackground: function(canvas) {
                                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                                if (!gl) return;
                                
                                const updateSize = () => {
                                    canvas.width = window.innerWidth;
                                    canvas.height = window.innerHeight;
                                    gl.viewport(0, 0, canvas.width, canvas.height);
                                };
                                updateSize();
                                window.addEventListener('resize', updateSize);
                                
                                // ç°¡å˜ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
                                const animate = () => {
                                    const time = Date.now() * 0.001;
                                    const r = 0.1 + 0.1 * Math.sin(time * 0.5);
                                    const g = 0.2 + 0.1 * Math.sin(time * 0.7);
                                    const b = 0.4 + 0.2 * Math.sin(time * 0.3);
                                    
                                    gl.clearColor(r, g, b, 1.0);
                                    gl.clear(gl.COLOR_BUFFER_BIT);
                                    requestAnimationFrame(animate);
                                };
                                animate();
                                console.log('Simple background initialized');
                            },
                            
                            initialize: function() {
                                console.log('ğŸš€ Initializing heartbeat dashboard...');
                                
                                // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºã‚’æ›´æ–°
                                const updateDebugStatus = (id, status) => {
                                    const element = document.getElementById(id);
                                    if (element) element.textContent = status;
                                };
                                
                                updateDebugStatus('jsStatus', 'Loaded âœ…');
                                
                                // èƒŒæ™¯è‰²ã‚’å¼·åˆ¶çš„ã«ã‚¯ãƒªã‚¢ï¼ˆãƒ‡ãƒãƒƒã‚°ï¼‰
                                document.body.style.background = 'transparent';
                                document.body.style.backgroundColor = 'transparent';
                                document.documentElement.style.background = 'transparent';
                                document.documentElement.style.backgroundColor = 'transparent';
                                console.log('ğŸ¨ Background colors forcefully cleared');
                                
                                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
                                console.log('Window size:', window.innerWidth, 'x', window.innerHeight);
                                console.log('User agent:', navigator.userAgent);
                                
                                // ãƒãƒ¼ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                                const heartIcon = document.querySelector('.heart-icon');
                                if (heartIcon) {
                                    heartIcon.style.animation = 'heartbeat 1.2s ease-in-out infinite';
                                    console.log('â¤ï¸ Heart icon animation applied');
                                } else {
                                    console.warn('âš ï¸ Heart icon not found');
                                }
                                
                                // ã‚­ãƒ£ãƒ³ãƒã‚¹è¦ç´ ã®ç¢ºèªãƒ»ä½œæˆ
                                let canvas = document.getElementById('vedaCanvas');
                                if (!canvas) {
                                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
                                    console.log('ğŸ¨ Canvas not found, creating new canvas element');
                                    canvas = document.createElement('canvas');
                                    canvas.id = 'vedaCanvas';
                                    canvas.className = 'veda-canvas';
                                } else {
                                    console.log('ğŸ¨ Canvas found:', canvas.width, 'x', canvas.height);
                                }
                                
                                updateDebugStatus('canvasStatus', 'Found/Created âœ…');
                                
                                if (canvas) {
                                    // è©³ç´°ãªDOMæ§‹é€ ã¨ã‚¹ã‚¿ã‚¤ãƒ«æƒ…å ±ã‚’å‡ºåŠ›
                                    console.log('ğŸ” Canvas parent:', canvas.parentElement);
                                    console.log('ğŸ” Canvas siblings:', Array.from(canvas.parentElement?.children || []));
                                    console.log('ğŸ” Document body style:', {
                                        background: window.getComputedStyle(document.body).background,
                                        backgroundColor: window.getComputedStyle(document.body).backgroundColor
                                    });
                                    console.log('ğŸ” HTML style:', {
                                        background: window.getComputedStyle(document.documentElement).background,
                                        backgroundColor: window.getComputedStyle(document.documentElement).backgroundColor
                                    });
                                    
                                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’èƒŒæ™¯ç”¨ã«è¨­å®š
                                    canvas.style.position = 'fixed';
                                    canvas.style.top = '0';
                                    canvas.style.left = '0';
                                    canvas.style.width = '100vw';
                                    canvas.style.height = '100vh';
                                    canvas.style.zIndex = '-1'; // èƒŒæ™¯ã¨ã—ã¦é…ç½®ï¼ˆä»–ã®è¦ç´ ã®ä¸‹ã«ï¼‰
                                    canvas.style.pointerEvents = 'none';
                                    canvas.style.display = 'block';
                                    canvas.style.visibility = 'visible';
                                    canvas.style.opacity = '1';
                                    canvas.style.backgroundColor = 'transparent';
                                    canvas.style.border = 'none';
                                    
                                    // è¦ªè¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚‚é©åˆ‡ã«è¨­å®š
                                    if (canvas.parentElement) {
                                        canvas.parentElement.style.position = 'relative';
                                        canvas.parentElement.style.overflow = 'visible';
                                    }
                                    
                                    // è¦ªè¦ç´ ã‹ã‚‰åˆ‡ã‚Šé›¢ã—ã¦bodyã«ç›´æ¥è¿½åŠ ï¼ˆç¢ºå®Ÿã«æœ€å‰é¢ã«ï¼‰
                                    document.body.appendChild(canvas);
                                    console.log('ğŸ”„ Canvas moved/added to body');
                                    
                                    console.log('ğŸ¨ Canvas style forcefully applied');
                                    console.log('ğŸ” Final canvas computed style:', {
                                        position: window.getComputedStyle(canvas).position,
                                        zIndex: window.getComputedStyle(canvas).zIndex,
                                        width: window.getComputedStyle(canvas).width,
                                        height: window.getComputedStyle(canvas).height,
                                        visibility: window.getComputedStyle(canvas).visibility,
                                        display: window.getComputedStyle(canvas).display,
                                        backgroundColor: window.getComputedStyle(canvas).backgroundColor,
                                        opacity: window.getComputedStyle(canvas).opacity
                                    });
                                    
                                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä½ç½®ã‚’è¦–è¦šçš„ã«ç¢ºèª
                                    const rect = canvas.getBoundingClientRect();
                                    console.log('ğŸ“ Canvas position:', {
                                        top: rect.top,
                                        left: rect.left,
                                        width: rect.width,
                                        height: rect.height,
                                        visible: rect.width > 0 && rect.height > 0
                                    });
                                    
                                    // å³åº§ã«ã‚µã‚¤ã‚ºè¨­å®š
                                    canvas.width = window.innerWidth;
                                    canvas.height = window.innerHeight;
                                    console.log('ğŸ“ Canvas resized to:', canvas.width, 'x', canvas.height);
                                } else {
                                    console.error('âŒ Canvas element could not be found or created!');
                                    updateDebugStatus('canvasStatus', 'Creation failed âŒ');
                                }
                                
                                // èƒŒæ™¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å°‘ã—é…å»¶ã•ã›ã¦åˆæœŸåŒ–ï¼ˆDOMç¢ºå®Ÿã«æº–å‚™ã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
                                setTimeout(() => {
                                    console.log('ğŸŒŒ Starting background initialization...');
                                    this.initializeVedaBackground();
                                }, 100);
                                
                                // åˆæœŸã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                                setTimeout(() => {
                                    this.animateMetrics();
                                }, 200);
                            },
                            
                            cleanup: function() {
                                this.stopRealTimeUpdate();
                                console.log('Heartbeat cleanup completed');
                            }
                        };
                    ");
                }
                
                // JavaScriptã®åˆæœŸåŒ–
                await JSRuntime.InvokeVoidAsync("heartbeatInterop.initialize");
                
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã¯ä¸è¦ãªã®ã§å‰Šé™¤
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript initialization failed: {ex.Message}");
            }
        }
        else
        {
            try
            {
                // ãƒ‡ãƒ¼ã‚¿æ›´æ–°å¾Œã«JavaScripté–¢æ•°ã‚’å‘¼ã³å‡ºã—
                await JSRuntime.InvokeVoidAsync("heartbeatInterop.animateMetrics");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"JavaScript update failed: {ex.Message}");
            }
        }
    }

    [JSInvokable]
    public async Task UpdateHeartbeatData()
    {
        await LoadHeartbeatData();
        StateHasChanged();
    }

    private async Task LoadHeartbeatData()
    {
        // å˜ç´”ãªåˆæœŸåŒ–ã®ã¿
        await Task.Delay(100);
        
        currentStatus = new HeartbeatInfo
        {
            IsHealthy = true
        };
    }

    public void Dispose()
    {
        try
        {
            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã‚’åœæ­¢
            JSRuntime.InvokeVoidAsync("heartbeatInterop.cleanup");
            dotNetRef?.Dispose();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Cleanup failed: {ex.Message}");
        }
    }

    private class HeartbeatInfo
    {
        public bool IsHealthy { get; set; }
    }
}