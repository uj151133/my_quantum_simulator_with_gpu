@inherits LayoutComponentBase
@inject IJSRuntime JSRuntime

<div class="page">
    <div class="sidebar">
        <NavMenu />
    </div>

    <main>
        <div class="top-row px-4">
            <div class="page-title">Quantum Simulator</div>
            <a href="https://learn.microsoft.com/aspnet/core/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body
        </article>
    </main>
</div>

<div id="blazor-error-ui" data-nosnippet>
    An unhandled error has occurred.
    <a href="." class="reload">Reload</a>
    <span class="dismiss">üóô</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Define GLTFLoader inline to ensure it's available
    THREE.GLTFLoader = function() {
        // Fallback implementation - we'll create a simple loader
        this.load = function(url, onLoad, onProgress, onError) {
            console.log('Using fallback GLTFLoader for:', url);
            // For now, trigger the error callback to use the fallback sphere
            if (onError) {
                onError(new Error('GLTFLoader fallback - using enhanced sphere'));
            }
        };
    };

    window.threeDObjectLoader = {
        initializeScene: function() {
            console.log('üöÄ Loading blackhole.glb model...');
            
            const canvas = document.getElementById('threejs-canvas');
            const statusDiv = document.getElementById('loading-status');
            
            if (!canvas) {
                console.error('‚ùå Canvas element not found');
                return;
            }
            
            console.log('‚úÖ Canvas found, size:', canvas.offsetWidth, 'x', canvas.offsetHeight);
            
            try {
                // Update status
                if (statusDiv) statusDiv.textContent = 'üîÆ Loading blackhole model...';
                
                // Scene setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111111);
                
                // Camera
                const camera = new THREE.PerspectiveCamera(
                    60, 
                    canvas.offsetWidth / canvas.offsetHeight, 
                    0.1, 
                    1000
                );
                camera.position.set(0, 0, 3);
                
                // Renderer
                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
                renderer.setPixelRatio(window.devicePixelRatio || 1);
                
                // Lighting for the blackhole
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const pointLight = new THREE.PointLight(0x9932cc, 1.5, 100);
                pointLight.position.set(2, 2, 2);
                scene.add(pointLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(-1, 1, 1);
                scene.add(directionalLight);
                
                // Load GLB model or fallback
                console.log('üîç Checking GLTFLoader availability:', typeof THREE.GLTFLoader);
                
                let blackholeModel = null;
                
                // Always use enhanced fallback for now to ensure 3D display works
                console.log('üåë Creating enhanced fallback blackhole...');
                if (statusDiv) statusDiv.textContent = 'ÔøΩ Creating enhanced blackhole...';
                
                // Enhanced fallback: create a more realistic blackhole
                const geometry = new THREE.SphereGeometry(0.8, 64, 64);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.95,
                    shininess: 100
                });
                const fallbackSphere = new THREE.Mesh(geometry, material);
                scene.add(fallbackSphere);
                blackholeModel = fallbackSphere;
                
                // Add accretion disk for realism
                const diskGeometry = new THREE.RingGeometry(1.2, 2.0, 32);
                const diskMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const disk = new THREE.Mesh(diskGeometry, diskMaterial);
                disk.rotation.x = Math.PI / 2;
                scene.add(disk);
                
                // Add some glow effect
                const glowGeometry = new THREE.SphereGeometry(1.0, 32, 32);
                const glowMaterial = new THREE.MeshPhongMaterial({
                    color: 0x9932cc,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                scene.add(glow);
                
                if (statusDiv) statusDiv.textContent = 'ÔøΩ Enhanced blackhole ready!';
                console.log('‚úÖ Enhanced fallback blackhole with disk and glow created');
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Rotate the blackhole if it exists
                    if (blackholeModel) {
                        blackholeModel.rotation.y += 0.005;
                        blackholeModel.rotation.x += 0.002;
                    }
                    
                    // Rotate the disk if it exists
                    if (disk) {
                        disk.rotation.z += 0.01;
                    }
                    
                    // Pulse the glow if it exists
                    if (glow) {
                        glow.scale.x = glow.scale.y = glow.scale.z = 1.0 + 0.1 * Math.sin(Date.now() * 0.003);
                    }
                    
                    renderer.render(scene, camera);
                }
                
                // Start animation
                animate();
                console.log('üé¨ Animation started with enhanced effects');
                
            } catch (error) {
                console.error('‚ùå Error in 3D setup:', error);
                if (statusDiv) statusDiv.textContent = '‚ùå 3D setup failed: ' + error.message;
            }
        }
    };
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        console.log('üåü DOM ready, waiting 2 seconds...');
        setTimeout(function() {
            try {
                if (window.threeDObjectLoader && window.THREE) {
                    window.threeDObjectLoader.initializeScene();
                } else {
                    console.error('‚ùå Three.js or threeDObjectLoader not available');
                }
            } catch (e) {
                console.error('‚ùå Error starting 3D:', e);
            }
        }, 2000);
    });
</script>

@code {
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Task.Delay(2500);
            try 
            {
                await JSRuntime.InvokeVoidAsync("threeDObjectLoader.initializeScene");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing 3D scene: {ex.Message}");
            }
        }
    }
}
