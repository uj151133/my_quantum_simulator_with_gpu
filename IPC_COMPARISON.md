# IPC通信方式の比較

## 1. Unix Domain Socket（現在実装済み）

### 特徴：
- **ファイルシステムパス** を使用（`/tmp/qmdd_sim_pipe`）
- **ストリーム型通信** - TCP/IPに似ているが、ローカルマシン専用
- **順序保証** - データの到着順序が保証される
- **同期的** - リクエスト/レスポンス型の通信

### メリット：
- 実装が簡単
- エラーハンドリングが容易
- 接続状態の管理が明確
- ポータブル（UNIX系OSで標準）

### デメリット：
- カーネル内でのデータコピーが2回発生
- ソケットの作成/破棄のオーバーヘッド
- 比較的低速

### 性能：
- **レイテンシ**: ~10-50μs
- **スループット**: ~1-5GB/s

## 2. 共有メモリ（新実装）

### 特徴：
- **メモリ空間を直接共有** - カーネルのコピーを回避
- **POSIX共有メモリ** (`shm_open`, `mmap`)を使用
- **非同期通信** - アトミック変数での状態管理
- **固定サイズバッファ** - プリアロケーション

### メリット：
- **最高性能** - ゼロコピー通信
- **低レイテンシ** - カーネル呼び出し最小限
- **高スループット** - メモリ帯域幅の限界まで利用可能
- **リアルタイム性** - 予測可能な性能

### デメリット：
- 実装が複雑
- 同期制御が必要
- バッファサイズの制限
- デバッグが困難

### 性能：
- **レイテンシ**: ~1-10μs
- **スループット**: ~10-50GB/s（メモリ帯域幅依存）

## 3. その他の方式

### Named Pipe (FIFO)
```cpp
// 簡単な実装例
mkfifo("/tmp/qmdd_pipe", 0666);
int fd = open("/tmp/qmdd_pipe", O_WRONLY);
write(fd, data, size);
```
- シンプル
- 一方向通信
- 双方向には2つのパイプが必要

### Message Queue
```cpp
// System V Message Queue
msgget(key, IPC_CREAT | 0666);
msgsnd(mqid, &msg, sizeof(msg), 0);
msgrcv(mqid, &msg, sizeof(msg), 0, 0);
```
- 非同期通信
- 優先度付きメッセージ
- サイズ制限あり

### Memory Mapped Files
```cpp
// ファイルベースの共有メモリ
int fd = open("shared_data.bin", O_RDWR | O_CREAT);
void* ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
```
- ファイルシステムに永続化
- 複数プロセス間共有
- ファイルI/Oのオーバーヘッド

## 推奨事項

### 現在の用途（量子回路シミュレーション）では：

1. **開発/デバッグ段階**: Unix Domain Socket
   - エラーハンドリングが簡単
   - デバッグツールが豊富
   - 安定性重視

2. **本番/性能重視**: 共有メモリ
   - 最高性能
   - 大きなデータ（状態ベクトル）の転送に有利
   - リアルタイム性

3. **ハイブリッド**: 制御は Socket、データは共有メモリ
   - 制御メッセージはSocketで確実に
   - 大容量データは共有メモリで高速に
